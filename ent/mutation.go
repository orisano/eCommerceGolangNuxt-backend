// Code generated by entc, DO NOT EDIT.

package ent

import (
	"bongo/ent/attribute"
	"bongo/ent/brand"
	"bongo/ent/cart"
	"bongo/ent/cartproduct"
	"bongo/ent/category"
	"bongo/ent/checkout"
	"bongo/ent/checkoutproduct"
	"bongo/ent/predicate"
	"bongo/ent/sellerproduct"
	"bongo/ent/sellerproductcategory"
	"bongo/ent/sellerproductimage"
	"bongo/ent/sellerproductvariation"
	"bongo/ent/sellerproductvariationvalues"
	"bongo/ent/sellerrequest"
	"bongo/ent/sellershop"
	"bongo/ent/shopcategory"
	"bongo/ent/user"
	"bongo/ent/userlocation"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/shopspring/decimal"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttribute                    = "Attribute"
	TypeBrand                        = "Brand"
	TypeCart                         = "Cart"
	TypeCartProduct                  = "CartProduct"
	TypeCategory                     = "Category"
	TypeCheckout                     = "Checkout"
	TypeCheckoutProduct              = "CheckoutProduct"
	TypeSellerProduct                = "SellerProduct"
	TypeSellerProductCategory        = "SellerProductCategory"
	TypeSellerProductImage           = "SellerProductImage"
	TypeSellerProductVariation       = "SellerProductVariation"
	TypeSellerProductVariationValues = "SellerProductVariationValues"
	TypeSellerRequest                = "SellerRequest"
	TypeSellerShop                   = "SellerShop"
	TypeShopCategory                 = "ShopCategory"
	TypeUser                         = "User"
	TypeUserLocation                 = "UserLocation"
)

// AttributeMutation represents an operation that mutates the Attribute nodes in the graph.
type AttributeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	clearedFields    map[string]struct{}
	attribute        map[int]struct{}
	removedattribute map[int]struct{}
	clearedattribute bool
	done             bool
	oldValue         func(context.Context) (*Attribute, error)
	predicates       []predicate.Attribute
}

var _ ent.Mutation = (*AttributeMutation)(nil)

// attributeOption allows management of the mutation configuration using functional options.
type attributeOption func(*AttributeMutation)

// newAttributeMutation creates new mutation for the Attribute entity.
func newAttributeMutation(c config, op Op, opts ...attributeOption) *AttributeMutation {
	m := &AttributeMutation{
		config:        c,
		op:            op,
		typ:           TypeAttribute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttributeID sets the ID field of the mutation.
func withAttributeID(id int) attributeOption {
	return func(m *AttributeMutation) {
		var (
			err   error
			once  sync.Once
			value *Attribute
		)
		m.oldValue = func(ctx context.Context) (*Attribute, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attribute.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttribute sets the old Attribute of the mutation.
func withAttribute(node *Attribute) attributeOption {
	return func(m *AttributeMutation) {
		m.oldValue = func(context.Context) (*Attribute, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttributeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttributeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttributeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttributeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attribute.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AttributeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AttributeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AttributeMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AttributeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttributeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttributeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttributeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttributeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttributeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AttributeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AttributeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AttributeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[attribute.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AttributeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[attribute.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AttributeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, attribute.FieldDeletedAt)
}

// AddAttributeIDs adds the "attribute" edge to the SellerProductVariationValues entity by ids.
func (m *AttributeMutation) AddAttributeIDs(ids ...int) {
	if m.attribute == nil {
		m.attribute = make(map[int]struct{})
	}
	for i := range ids {
		m.attribute[ids[i]] = struct{}{}
	}
}

// ClearAttribute clears the "attribute" edge to the SellerProductVariationValues entity.
func (m *AttributeMutation) ClearAttribute() {
	m.clearedattribute = true
}

// AttributeCleared reports if the "attribute" edge to the SellerProductVariationValues entity was cleared.
func (m *AttributeMutation) AttributeCleared() bool {
	return m.clearedattribute
}

// RemoveAttributeIDs removes the "attribute" edge to the SellerProductVariationValues entity by IDs.
func (m *AttributeMutation) RemoveAttributeIDs(ids ...int) {
	if m.removedattribute == nil {
		m.removedattribute = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attribute, ids[i])
		m.removedattribute[ids[i]] = struct{}{}
	}
}

// RemovedAttribute returns the removed IDs of the "attribute" edge to the SellerProductVariationValues entity.
func (m *AttributeMutation) RemovedAttributeIDs() (ids []int) {
	for id := range m.removedattribute {
		ids = append(ids, id)
	}
	return
}

// AttributeIDs returns the "attribute" edge IDs in the mutation.
func (m *AttributeMutation) AttributeIDs() (ids []int) {
	for id := range m.attribute {
		ids = append(ids, id)
	}
	return
}

// ResetAttribute resets all changes to the "attribute" edge.
func (m *AttributeMutation) ResetAttribute() {
	m.attribute = nil
	m.clearedattribute = false
	m.removedattribute = nil
}

// Where appends a list predicates to the AttributeMutation builder.
func (m *AttributeMutation) Where(ps ...predicate.Attribute) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AttributeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Attribute).
func (m *AttributeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttributeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, attribute.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, attribute.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attribute.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, attribute.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttributeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attribute.FieldName:
		return m.Name()
	case attribute.FieldCreatedAt:
		return m.CreatedAt()
	case attribute.FieldUpdatedAt:
		return m.UpdatedAt()
	case attribute.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttributeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attribute.FieldName:
		return m.OldName(ctx)
	case attribute.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attribute.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attribute.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Attribute field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attribute.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case attribute.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attribute.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attribute.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Attribute field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttributeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttributeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Attribute numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttributeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attribute.FieldDeletedAt) {
		fields = append(fields, attribute.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttributeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttributeMutation) ClearField(name string) error {
	switch name {
	case attribute.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Attribute nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttributeMutation) ResetField(name string) error {
	switch name {
	case attribute.FieldName:
		m.ResetName()
		return nil
	case attribute.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attribute.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attribute.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Attribute field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttributeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.attribute != nil {
		edges = append(edges, attribute.EdgeAttribute)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttributeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attribute.EdgeAttribute:
		ids := make([]ent.Value, 0, len(m.attribute))
		for id := range m.attribute {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttributeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedattribute != nil {
		edges = append(edges, attribute.EdgeAttribute)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttributeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case attribute.EdgeAttribute:
		ids := make([]ent.Value, 0, len(m.removedattribute))
		for id := range m.removedattribute {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttributeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedattribute {
		edges = append(edges, attribute.EdgeAttribute)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttributeMutation) EdgeCleared(name string) bool {
	switch name {
	case attribute.EdgeAttribute:
		return m.clearedattribute
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttributeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Attribute unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttributeMutation) ResetEdge(name string) error {
	switch name {
	case attribute.EdgeAttribute:
		m.ResetAttribute()
		return nil
	}
	return fmt.Errorf("unknown Attribute edge %s", name)
}

// BrandMutation represents an operation that mutates the Brand nodes in the graph.
type BrandMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	brand         map[int]struct{}
	removedbrand  map[int]struct{}
	clearedbrand  bool
	done          bool
	oldValue      func(context.Context) (*Brand, error)
	predicates    []predicate.Brand
}

var _ ent.Mutation = (*BrandMutation)(nil)

// brandOption allows management of the mutation configuration using functional options.
type brandOption func(*BrandMutation)

// newBrandMutation creates new mutation for the Brand entity.
func newBrandMutation(c config, op Op, opts ...brandOption) *BrandMutation {
	m := &BrandMutation{
		config:        c,
		op:            op,
		typ:           TypeBrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBrandID sets the ID field of the mutation.
func withBrandID(id int) brandOption {
	return func(m *BrandMutation) {
		var (
			err   error
			once  sync.Once
			value *Brand
		)
		m.oldValue = func(ctx context.Context) (*Brand, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Brand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBrand sets the old Brand of the mutation.
func withBrand(node *Brand) brandOption {
	return func(m *BrandMutation) {
		m.oldValue = func(context.Context) (*Brand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BrandMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BrandMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Brand.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BrandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BrandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BrandMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BrandMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BrandMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BrandMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BrandMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BrandMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BrandMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BrandMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BrandMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BrandMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[brand.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BrandMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[brand.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BrandMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, brand.FieldDeletedAt)
}

// AddBrandIDs adds the "brand" edge to the SellerProduct entity by ids.
func (m *BrandMutation) AddBrandIDs(ids ...int) {
	if m.brand == nil {
		m.brand = make(map[int]struct{})
	}
	for i := range ids {
		m.brand[ids[i]] = struct{}{}
	}
}

// ClearBrand clears the "brand" edge to the SellerProduct entity.
func (m *BrandMutation) ClearBrand() {
	m.clearedbrand = true
}

// BrandCleared reports if the "brand" edge to the SellerProduct entity was cleared.
func (m *BrandMutation) BrandCleared() bool {
	return m.clearedbrand
}

// RemoveBrandIDs removes the "brand" edge to the SellerProduct entity by IDs.
func (m *BrandMutation) RemoveBrandIDs(ids ...int) {
	if m.removedbrand == nil {
		m.removedbrand = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.brand, ids[i])
		m.removedbrand[ids[i]] = struct{}{}
	}
}

// RemovedBrand returns the removed IDs of the "brand" edge to the SellerProduct entity.
func (m *BrandMutation) RemovedBrandIDs() (ids []int) {
	for id := range m.removedbrand {
		ids = append(ids, id)
	}
	return
}

// BrandIDs returns the "brand" edge IDs in the mutation.
func (m *BrandMutation) BrandIDs() (ids []int) {
	for id := range m.brand {
		ids = append(ids, id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *BrandMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
	m.removedbrand = nil
}

// Where appends a list predicates to the BrandMutation builder.
func (m *BrandMutation) Where(ps ...predicate.Brand) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BrandMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Brand).
func (m *BrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BrandMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, brand.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, brand.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, brand.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, brand.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case brand.FieldName:
		return m.Name()
	case brand.FieldCreatedAt:
		return m.CreatedAt()
	case brand.FieldUpdatedAt:
		return m.UpdatedAt()
	case brand.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case brand.FieldName:
		return m.OldName(ctx)
	case brand.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case brand.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case brand.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Brand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case brand.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case brand.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case brand.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case brand.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BrandMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BrandMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Brand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BrandMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(brand.FieldDeletedAt) {
		fields = append(fields, brand.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BrandMutation) ClearField(name string) error {
	switch name {
	case brand.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Brand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BrandMutation) ResetField(name string) error {
	switch name {
	case brand.FieldName:
		m.ResetName()
		return nil
	case brand.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case brand.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case brand.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.brand != nil {
		edges = append(edges, brand.EdgeBrand)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BrandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeBrand:
		ids := make([]ent.Value, 0, len(m.brand))
		for id := range m.brand {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbrand != nil {
		edges = append(edges, brand.EdgeBrand)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BrandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeBrand:
		ids := make([]ent.Value, 0, len(m.removedbrand))
		for id := range m.removedbrand {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbrand {
		edges = append(edges, brand.EdgeBrand)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BrandMutation) EdgeCleared(name string) bool {
	switch name {
	case brand.EdgeBrand:
		return m.clearedbrand
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BrandMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Brand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BrandMutation) ResetEdge(name string) error {
	switch name {
	case brand.EdgeBrand:
		m.ResetBrand()
		return nil
	}
	return fmt.Errorf("unknown Brand edge %s", name)
}

// CartMutation represents an operation that mutates the Cart nodes in the graph.
type CartMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	slug                 *string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	clearedFields        map[string]struct{}
	user                 *int
	cleareduser          bool
	cart_products        map[int]struct{}
	removedcart_products map[int]struct{}
	clearedcart_products bool
	checkout             *int
	clearedcheckout      bool
	done                 bool
	oldValue             func(context.Context) (*Cart, error)
	predicates           []predicate.Cart
}

var _ ent.Mutation = (*CartMutation)(nil)

// cartOption allows management of the mutation configuration using functional options.
type cartOption func(*CartMutation)

// newCartMutation creates new mutation for the Cart entity.
func newCartMutation(c config, op Op, opts ...cartOption) *CartMutation {
	m := &CartMutation{
		config:        c,
		op:            op,
		typ:           TypeCart,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCartID sets the ID field of the mutation.
func withCartID(id int) cartOption {
	return func(m *CartMutation) {
		var (
			err   error
			once  sync.Once
			value *Cart
		)
		m.oldValue = func(ctx context.Context) (*Cart, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cart.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCart sets the old Cart of the mutation.
func withCart(node *Cart) cartOption {
	return func(m *CartMutation) {
		m.oldValue = func(context.Context) (*Cart, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CartMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CartMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CartMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CartMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cart.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *CartMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CartMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Cart entity.
// If the Cart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CartMutation) ResetSlug() {
	m.slug = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CartMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CartMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cart entity.
// If the Cart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CartMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CartMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CartMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cart entity.
// If the Cart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CartMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CartMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CartMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Cart entity.
// If the Cart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CartMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[cart.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CartMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[cart.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CartMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, cart.FieldDeletedAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CartMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CartMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CartMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CartMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CartMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CartMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCartProductIDs adds the "cart_products" edge to the CartProduct entity by ids.
func (m *CartMutation) AddCartProductIDs(ids ...int) {
	if m.cart_products == nil {
		m.cart_products = make(map[int]struct{})
	}
	for i := range ids {
		m.cart_products[ids[i]] = struct{}{}
	}
}

// ClearCartProducts clears the "cart_products" edge to the CartProduct entity.
func (m *CartMutation) ClearCartProducts() {
	m.clearedcart_products = true
}

// CartProductsCleared reports if the "cart_products" edge to the CartProduct entity was cleared.
func (m *CartMutation) CartProductsCleared() bool {
	return m.clearedcart_products
}

// RemoveCartProductIDs removes the "cart_products" edge to the CartProduct entity by IDs.
func (m *CartMutation) RemoveCartProductIDs(ids ...int) {
	if m.removedcart_products == nil {
		m.removedcart_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cart_products, ids[i])
		m.removedcart_products[ids[i]] = struct{}{}
	}
}

// RemovedCartProducts returns the removed IDs of the "cart_products" edge to the CartProduct entity.
func (m *CartMutation) RemovedCartProductsIDs() (ids []int) {
	for id := range m.removedcart_products {
		ids = append(ids, id)
	}
	return
}

// CartProductsIDs returns the "cart_products" edge IDs in the mutation.
func (m *CartMutation) CartProductsIDs() (ids []int) {
	for id := range m.cart_products {
		ids = append(ids, id)
	}
	return
}

// ResetCartProducts resets all changes to the "cart_products" edge.
func (m *CartMutation) ResetCartProducts() {
	m.cart_products = nil
	m.clearedcart_products = false
	m.removedcart_products = nil
}

// SetCheckoutID sets the "checkout" edge to the Checkout entity by id.
func (m *CartMutation) SetCheckoutID(id int) {
	m.checkout = &id
}

// ClearCheckout clears the "checkout" edge to the Checkout entity.
func (m *CartMutation) ClearCheckout() {
	m.clearedcheckout = true
}

// CheckoutCleared reports if the "checkout" edge to the Checkout entity was cleared.
func (m *CartMutation) CheckoutCleared() bool {
	return m.clearedcheckout
}

// CheckoutID returns the "checkout" edge ID in the mutation.
func (m *CartMutation) CheckoutID() (id int, exists bool) {
	if m.checkout != nil {
		return *m.checkout, true
	}
	return
}

// CheckoutIDs returns the "checkout" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CheckoutID instead. It exists only for internal usage by the builders.
func (m *CartMutation) CheckoutIDs() (ids []int) {
	if id := m.checkout; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCheckout resets all changes to the "checkout" edge.
func (m *CartMutation) ResetCheckout() {
	m.checkout = nil
	m.clearedcheckout = false
}

// Where appends a list predicates to the CartMutation builder.
func (m *CartMutation) Where(ps ...predicate.Cart) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CartMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cart).
func (m *CartMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CartMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.slug != nil {
		fields = append(fields, cart.FieldSlug)
	}
	if m.created_at != nil {
		fields = append(fields, cart.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cart.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cart.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CartMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cart.FieldSlug:
		return m.Slug()
	case cart.FieldCreatedAt:
		return m.CreatedAt()
	case cart.FieldUpdatedAt:
		return m.UpdatedAt()
	case cart.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CartMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cart.FieldSlug:
		return m.OldSlug(ctx)
	case cart.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cart.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cart.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Cart field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CartMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cart.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case cart.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cart.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cart.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Cart field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CartMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CartMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CartMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cart numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CartMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cart.FieldDeletedAt) {
		fields = append(fields, cart.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CartMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CartMutation) ClearField(name string) error {
	switch name {
	case cart.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Cart nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CartMutation) ResetField(name string) error {
	switch name {
	case cart.FieldSlug:
		m.ResetSlug()
		return nil
	case cart.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cart.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cart.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Cart field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CartMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, cart.EdgeUser)
	}
	if m.cart_products != nil {
		edges = append(edges, cart.EdgeCartProducts)
	}
	if m.checkout != nil {
		edges = append(edges, cart.EdgeCheckout)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CartMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cart.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case cart.EdgeCartProducts:
		ids := make([]ent.Value, 0, len(m.cart_products))
		for id := range m.cart_products {
			ids = append(ids, id)
		}
		return ids
	case cart.EdgeCheckout:
		if id := m.checkout; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CartMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcart_products != nil {
		edges = append(edges, cart.EdgeCartProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CartMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cart.EdgeCartProducts:
		ids := make([]ent.Value, 0, len(m.removedcart_products))
		for id := range m.removedcart_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CartMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, cart.EdgeUser)
	}
	if m.clearedcart_products {
		edges = append(edges, cart.EdgeCartProducts)
	}
	if m.clearedcheckout {
		edges = append(edges, cart.EdgeCheckout)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CartMutation) EdgeCleared(name string) bool {
	switch name {
	case cart.EdgeUser:
		return m.cleareduser
	case cart.EdgeCartProducts:
		return m.clearedcart_products
	case cart.EdgeCheckout:
		return m.clearedcheckout
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CartMutation) ClearEdge(name string) error {
	switch name {
	case cart.EdgeUser:
		m.ClearUser()
		return nil
	case cart.EdgeCheckout:
		m.ClearCheckout()
		return nil
	}
	return fmt.Errorf("unknown Cart unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CartMutation) ResetEdge(name string) error {
	switch name {
	case cart.EdgeUser:
		m.ResetUser()
		return nil
	case cart.EdgeCartProducts:
		m.ResetCartProducts()
		return nil
	case cart.EdgeCheckout:
		m.ResetCheckout()
		return nil
	}
	return fmt.Errorf("unknown Cart edge %s", name)
}

// CartProductMutation represents an operation that mutates the CartProduct nodes in the graph.
type CartProductMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	quantity                        *int
	addquantity                     *int
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	clearedFields                   map[string]struct{}
	seller_product                  *int
	clearedseller_product           bool
	cart                            *int
	clearedcart                     bool
	seller_product_variation        *int
	clearedseller_product_variation bool
	done                            bool
	oldValue                        func(context.Context) (*CartProduct, error)
	predicates                      []predicate.CartProduct
}

var _ ent.Mutation = (*CartProductMutation)(nil)

// cartproductOption allows management of the mutation configuration using functional options.
type cartproductOption func(*CartProductMutation)

// newCartProductMutation creates new mutation for the CartProduct entity.
func newCartProductMutation(c config, op Op, opts ...cartproductOption) *CartProductMutation {
	m := &CartProductMutation{
		config:        c,
		op:            op,
		typ:           TypeCartProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCartProductID sets the ID field of the mutation.
func withCartProductID(id int) cartproductOption {
	return func(m *CartProductMutation) {
		var (
			err   error
			once  sync.Once
			value *CartProduct
		)
		m.oldValue = func(ctx context.Context) (*CartProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CartProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCartProduct sets the old CartProduct of the mutation.
func withCartProduct(node *CartProduct) cartproductOption {
	return func(m *CartProductMutation) {
		m.oldValue = func(context.Context) (*CartProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CartProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CartProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CartProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CartProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CartProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *CartProductMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *CartProductMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the CartProduct entity.
// If the CartProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartProductMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *CartProductMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *CartProductMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *CartProductMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CartProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CartProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CartProduct entity.
// If the CartProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CartProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CartProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CartProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CartProduct entity.
// If the CartProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CartProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CartProductMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CartProductMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CartProduct entity.
// If the CartProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartProductMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CartProductMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[cartproduct.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CartProductMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[cartproduct.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CartProductMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, cartproduct.FieldDeletedAt)
}

// SetSellerProductID sets the "seller_product" edge to the SellerProduct entity by id.
func (m *CartProductMutation) SetSellerProductID(id int) {
	m.seller_product = &id
}

// ClearSellerProduct clears the "seller_product" edge to the SellerProduct entity.
func (m *CartProductMutation) ClearSellerProduct() {
	m.clearedseller_product = true
}

// SellerProductCleared reports if the "seller_product" edge to the SellerProduct entity was cleared.
func (m *CartProductMutation) SellerProductCleared() bool {
	return m.clearedseller_product
}

// SellerProductID returns the "seller_product" edge ID in the mutation.
func (m *CartProductMutation) SellerProductID() (id int, exists bool) {
	if m.seller_product != nil {
		return *m.seller_product, true
	}
	return
}

// SellerProductIDs returns the "seller_product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SellerProductID instead. It exists only for internal usage by the builders.
func (m *CartProductMutation) SellerProductIDs() (ids []int) {
	if id := m.seller_product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSellerProduct resets all changes to the "seller_product" edge.
func (m *CartProductMutation) ResetSellerProduct() {
	m.seller_product = nil
	m.clearedseller_product = false
}

// SetCartID sets the "cart" edge to the Cart entity by id.
func (m *CartProductMutation) SetCartID(id int) {
	m.cart = &id
}

// ClearCart clears the "cart" edge to the Cart entity.
func (m *CartProductMutation) ClearCart() {
	m.clearedcart = true
}

// CartCleared reports if the "cart" edge to the Cart entity was cleared.
func (m *CartProductMutation) CartCleared() bool {
	return m.clearedcart
}

// CartID returns the "cart" edge ID in the mutation.
func (m *CartProductMutation) CartID() (id int, exists bool) {
	if m.cart != nil {
		return *m.cart, true
	}
	return
}

// CartIDs returns the "cart" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CartID instead. It exists only for internal usage by the builders.
func (m *CartProductMutation) CartIDs() (ids []int) {
	if id := m.cart; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCart resets all changes to the "cart" edge.
func (m *CartProductMutation) ResetCart() {
	m.cart = nil
	m.clearedcart = false
}

// SetSellerProductVariationID sets the "seller_product_variation" edge to the SellerProductVariation entity by id.
func (m *CartProductMutation) SetSellerProductVariationID(id int) {
	m.seller_product_variation = &id
}

// ClearSellerProductVariation clears the "seller_product_variation" edge to the SellerProductVariation entity.
func (m *CartProductMutation) ClearSellerProductVariation() {
	m.clearedseller_product_variation = true
}

// SellerProductVariationCleared reports if the "seller_product_variation" edge to the SellerProductVariation entity was cleared.
func (m *CartProductMutation) SellerProductVariationCleared() bool {
	return m.clearedseller_product_variation
}

// SellerProductVariationID returns the "seller_product_variation" edge ID in the mutation.
func (m *CartProductMutation) SellerProductVariationID() (id int, exists bool) {
	if m.seller_product_variation != nil {
		return *m.seller_product_variation, true
	}
	return
}

// SellerProductVariationIDs returns the "seller_product_variation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SellerProductVariationID instead. It exists only for internal usage by the builders.
func (m *CartProductMutation) SellerProductVariationIDs() (ids []int) {
	if id := m.seller_product_variation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSellerProductVariation resets all changes to the "seller_product_variation" edge.
func (m *CartProductMutation) ResetSellerProductVariation() {
	m.seller_product_variation = nil
	m.clearedseller_product_variation = false
}

// Where appends a list predicates to the CartProductMutation builder.
func (m *CartProductMutation) Where(ps ...predicate.CartProduct) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CartProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CartProduct).
func (m *CartProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CartProductMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.quantity != nil {
		fields = append(fields, cartproduct.FieldQuantity)
	}
	if m.created_at != nil {
		fields = append(fields, cartproduct.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cartproduct.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cartproduct.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CartProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cartproduct.FieldQuantity:
		return m.Quantity()
	case cartproduct.FieldCreatedAt:
		return m.CreatedAt()
	case cartproduct.FieldUpdatedAt:
		return m.UpdatedAt()
	case cartproduct.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CartProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cartproduct.FieldQuantity:
		return m.OldQuantity(ctx)
	case cartproduct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cartproduct.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cartproduct.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CartProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CartProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cartproduct.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case cartproduct.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cartproduct.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cartproduct.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CartProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CartProductMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, cartproduct.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CartProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cartproduct.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CartProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cartproduct.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown CartProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CartProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cartproduct.FieldDeletedAt) {
		fields = append(fields, cartproduct.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CartProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CartProductMutation) ClearField(name string) error {
	switch name {
	case cartproduct.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CartProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CartProductMutation) ResetField(name string) error {
	switch name {
	case cartproduct.FieldQuantity:
		m.ResetQuantity()
		return nil
	case cartproduct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cartproduct.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cartproduct.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CartProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CartProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.seller_product != nil {
		edges = append(edges, cartproduct.EdgeSellerProduct)
	}
	if m.cart != nil {
		edges = append(edges, cartproduct.EdgeCart)
	}
	if m.seller_product_variation != nil {
		edges = append(edges, cartproduct.EdgeSellerProductVariation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CartProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cartproduct.EdgeSellerProduct:
		if id := m.seller_product; id != nil {
			return []ent.Value{*id}
		}
	case cartproduct.EdgeCart:
		if id := m.cart; id != nil {
			return []ent.Value{*id}
		}
	case cartproduct.EdgeSellerProductVariation:
		if id := m.seller_product_variation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CartProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CartProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CartProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedseller_product {
		edges = append(edges, cartproduct.EdgeSellerProduct)
	}
	if m.clearedcart {
		edges = append(edges, cartproduct.EdgeCart)
	}
	if m.clearedseller_product_variation {
		edges = append(edges, cartproduct.EdgeSellerProductVariation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CartProductMutation) EdgeCleared(name string) bool {
	switch name {
	case cartproduct.EdgeSellerProduct:
		return m.clearedseller_product
	case cartproduct.EdgeCart:
		return m.clearedcart
	case cartproduct.EdgeSellerProductVariation:
		return m.clearedseller_product_variation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CartProductMutation) ClearEdge(name string) error {
	switch name {
	case cartproduct.EdgeSellerProduct:
		m.ClearSellerProduct()
		return nil
	case cartproduct.EdgeCart:
		m.ClearCart()
		return nil
	case cartproduct.EdgeSellerProductVariation:
		m.ClearSellerProductVariation()
		return nil
	}
	return fmt.Errorf("unknown CartProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CartProductMutation) ResetEdge(name string) error {
	switch name {
	case cartproduct.EdgeSellerProduct:
		m.ResetSellerProduct()
		return nil
	case cartproduct.EdgeCart:
		m.ResetCart()
		return nil
	case cartproduct.EdgeSellerProductVariation:
		m.ResetSellerProductVariation()
		return nil
	}
	return fmt.Errorf("unknown CartProduct edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	slug                      *string
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	clearedFields             map[string]struct{}
	shop_category             *int
	clearedshop_category      bool
	parent                    *int
	clearedparent             bool
	children                  map[int]struct{}
	removedchildren           map[int]struct{}
	clearedchildren           bool
	product_categories        map[int]struct{}
	removedproduct_categories map[int]struct{}
	clearedproduct_categories bool
	seller_products           map[int]struct{}
	removedseller_products    map[int]struct{}
	clearedseller_products    bool
	done                      bool
	oldValue                  func(context.Context) (*Category, error)
	predicates                []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *CategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[category.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[category.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, category.FieldDeletedAt)
}

// SetShopCategoryID sets the "shop_category" edge to the ShopCategory entity by id.
func (m *CategoryMutation) SetShopCategoryID(id int) {
	m.shop_category = &id
}

// ClearShopCategory clears the "shop_category" edge to the ShopCategory entity.
func (m *CategoryMutation) ClearShopCategory() {
	m.clearedshop_category = true
}

// ShopCategoryCleared reports if the "shop_category" edge to the ShopCategory entity was cleared.
func (m *CategoryMutation) ShopCategoryCleared() bool {
	return m.clearedshop_category
}

// ShopCategoryID returns the "shop_category" edge ID in the mutation.
func (m *CategoryMutation) ShopCategoryID() (id int, exists bool) {
	if m.shop_category != nil {
		return *m.shop_category, true
	}
	return
}

// ShopCategoryIDs returns the "shop_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShopCategoryID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ShopCategoryIDs() (ids []int) {
	if id := m.shop_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShopCategory resets all changes to the "shop_category" edge.
func (m *CategoryMutation) ResetShopCategory() {
	m.shop_category = nil
	m.clearedshop_category = false
}

// SetParentID sets the "parent" edge to the Category entity by id.
func (m *CategoryMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Category entity.
func (m *CategoryMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Category entity was cleared.
func (m *CategoryMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *CategoryMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Category entity by ids.
func (m *CategoryMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Category entity.
func (m *CategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Category entity was cleared.
func (m *CategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Category entity by IDs.
func (m *CategoryMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Category entity.
func (m *CategoryMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CategoryMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddProductCategoryIDs adds the "product_categories" edge to the SellerProductCategory entity by ids.
func (m *CategoryMutation) AddProductCategoryIDs(ids ...int) {
	if m.product_categories == nil {
		m.product_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.product_categories[ids[i]] = struct{}{}
	}
}

// ClearProductCategories clears the "product_categories" edge to the SellerProductCategory entity.
func (m *CategoryMutation) ClearProductCategories() {
	m.clearedproduct_categories = true
}

// ProductCategoriesCleared reports if the "product_categories" edge to the SellerProductCategory entity was cleared.
func (m *CategoryMutation) ProductCategoriesCleared() bool {
	return m.clearedproduct_categories
}

// RemoveProductCategoryIDs removes the "product_categories" edge to the SellerProductCategory entity by IDs.
func (m *CategoryMutation) RemoveProductCategoryIDs(ids ...int) {
	if m.removedproduct_categories == nil {
		m.removedproduct_categories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_categories, ids[i])
		m.removedproduct_categories[ids[i]] = struct{}{}
	}
}

// RemovedProductCategories returns the removed IDs of the "product_categories" edge to the SellerProductCategory entity.
func (m *CategoryMutation) RemovedProductCategoriesIDs() (ids []int) {
	for id := range m.removedproduct_categories {
		ids = append(ids, id)
	}
	return
}

// ProductCategoriesIDs returns the "product_categories" edge IDs in the mutation.
func (m *CategoryMutation) ProductCategoriesIDs() (ids []int) {
	for id := range m.product_categories {
		ids = append(ids, id)
	}
	return
}

// ResetProductCategories resets all changes to the "product_categories" edge.
func (m *CategoryMutation) ResetProductCategories() {
	m.product_categories = nil
	m.clearedproduct_categories = false
	m.removedproduct_categories = nil
}

// AddSellerProductIDs adds the "seller_products" edge to the SellerProduct entity by ids.
func (m *CategoryMutation) AddSellerProductIDs(ids ...int) {
	if m.seller_products == nil {
		m.seller_products = make(map[int]struct{})
	}
	for i := range ids {
		m.seller_products[ids[i]] = struct{}{}
	}
}

// ClearSellerProducts clears the "seller_products" edge to the SellerProduct entity.
func (m *CategoryMutation) ClearSellerProducts() {
	m.clearedseller_products = true
}

// SellerProductsCleared reports if the "seller_products" edge to the SellerProduct entity was cleared.
func (m *CategoryMutation) SellerProductsCleared() bool {
	return m.clearedseller_products
}

// RemoveSellerProductIDs removes the "seller_products" edge to the SellerProduct entity by IDs.
func (m *CategoryMutation) RemoveSellerProductIDs(ids ...int) {
	if m.removedseller_products == nil {
		m.removedseller_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seller_products, ids[i])
		m.removedseller_products[ids[i]] = struct{}{}
	}
}

// RemovedSellerProducts returns the removed IDs of the "seller_products" edge to the SellerProduct entity.
func (m *CategoryMutation) RemovedSellerProductsIDs() (ids []int) {
	for id := range m.removedseller_products {
		ids = append(ids, id)
	}
	return
}

// SellerProductsIDs returns the "seller_products" edge IDs in the mutation.
func (m *CategoryMutation) SellerProductsIDs() (ids []int) {
	for id := range m.seller_products {
		ids = append(ids, id)
	}
	return
}

// ResetSellerProducts resets all changes to the "seller_products" edge.
func (m *CategoryMutation) ResetSellerProducts() {
	m.seller_products = nil
	m.clearedseller_products = false
	m.removedseller_products = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, category.FieldSlug)
	}
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, category.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	case category.FieldSlug:
		return m.Slug()
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldSlug:
		return m.OldSlug(ctx)
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldDeletedAt) {
		fields = append(fields, category.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldSlug:
		m.ResetSlug()
		return nil
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.shop_category != nil {
		edges = append(edges, category.EdgeShopCategory)
	}
	if m.parent != nil {
		edges = append(edges, category.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, category.EdgeChildren)
	}
	if m.product_categories != nil {
		edges = append(edges, category.EdgeProductCategories)
	}
	if m.seller_products != nil {
		edges = append(edges, category.EdgeSellerProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeShopCategory:
		if id := m.shop_category; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeProductCategories:
		ids := make([]ent.Value, 0, len(m.product_categories))
		for id := range m.product_categories {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeSellerProducts:
		ids := make([]ent.Value, 0, len(m.seller_products))
		for id := range m.seller_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedchildren != nil {
		edges = append(edges, category.EdgeChildren)
	}
	if m.removedproduct_categories != nil {
		edges = append(edges, category.EdgeProductCategories)
	}
	if m.removedseller_products != nil {
		edges = append(edges, category.EdgeSellerProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeProductCategories:
		ids := make([]ent.Value, 0, len(m.removedproduct_categories))
		for id := range m.removedproduct_categories {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeSellerProducts:
		ids := make([]ent.Value, 0, len(m.removedseller_products))
		for id := range m.removedseller_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedshop_category {
		edges = append(edges, category.EdgeShopCategory)
	}
	if m.clearedparent {
		edges = append(edges, category.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, category.EdgeChildren)
	}
	if m.clearedproduct_categories {
		edges = append(edges, category.EdgeProductCategories)
	}
	if m.clearedseller_products {
		edges = append(edges, category.EdgeSellerProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeShopCategory:
		return m.clearedshop_category
	case category.EdgeParent:
		return m.clearedparent
	case category.EdgeChildren:
		return m.clearedchildren
	case category.EdgeProductCategories:
		return m.clearedproduct_categories
	case category.EdgeSellerProducts:
		return m.clearedseller_products
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeShopCategory:
		m.ClearShopCategory()
		return nil
	case category.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeShopCategory:
		m.ResetShopCategory()
		return nil
	case category.EdgeParent:
		m.ResetParent()
		return nil
	case category.EdgeChildren:
		m.ResetChildren()
		return nil
	case category.EdgeProductCategories:
		m.ResetProductCategories()
		return nil
	case category.EdgeSellerProducts:
		m.ResetSellerProducts()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CheckoutMutation represents an operation that mutates the Checkout nodes in the graph.
type CheckoutMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	total_price              *decimal.Decimal
	addtotal_price           *decimal.Decimal
	completed                *bool
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	clearedFields            map[string]struct{}
	user                     *int
	cleareduser              bool
	location                 *int
	clearedlocation          bool
	cart                     *int
	clearedcart              bool
	checkout_products        map[int]struct{}
	removedcheckout_products map[int]struct{}
	clearedcheckout_products bool
	done                     bool
	oldValue                 func(context.Context) (*Checkout, error)
	predicates               []predicate.Checkout
}

var _ ent.Mutation = (*CheckoutMutation)(nil)

// checkoutOption allows management of the mutation configuration using functional options.
type checkoutOption func(*CheckoutMutation)

// newCheckoutMutation creates new mutation for the Checkout entity.
func newCheckoutMutation(c config, op Op, opts ...checkoutOption) *CheckoutMutation {
	m := &CheckoutMutation{
		config:        c,
		op:            op,
		typ:           TypeCheckout,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckoutID sets the ID field of the mutation.
func withCheckoutID(id int) checkoutOption {
	return func(m *CheckoutMutation) {
		var (
			err   error
			once  sync.Once
			value *Checkout
		)
		m.oldValue = func(ctx context.Context) (*Checkout, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Checkout.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheckout sets the old Checkout of the mutation.
func withCheckout(node *Checkout) checkoutOption {
	return func(m *CheckoutMutation) {
		m.oldValue = func(context.Context) (*Checkout, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckoutMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckoutMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CheckoutMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CheckoutMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Checkout.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTotalPrice sets the "total_price" field.
func (m *CheckoutMutation) SetTotalPrice(d decimal.Decimal) {
	m.total_price = &d
	m.addtotal_price = nil
}

// TotalPrice returns the value of the "total_price" field in the mutation.
func (m *CheckoutMutation) TotalPrice() (r decimal.Decimal, exists bool) {
	v := m.total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPrice returns the old "total_price" field's value of the Checkout entity.
// If the Checkout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutMutation) OldTotalPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPrice: %w", err)
	}
	return oldValue.TotalPrice, nil
}

// AddTotalPrice adds d to the "total_price" field.
func (m *CheckoutMutation) AddTotalPrice(d decimal.Decimal) {
	if m.addtotal_price != nil {
		*m.addtotal_price = m.addtotal_price.Add(d)
	} else {
		m.addtotal_price = &d
	}
}

// AddedTotalPrice returns the value that was added to the "total_price" field in this mutation.
func (m *CheckoutMutation) AddedTotalPrice() (r decimal.Decimal, exists bool) {
	v := m.addtotal_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPrice resets all changes to the "total_price" field.
func (m *CheckoutMutation) ResetTotalPrice() {
	m.total_price = nil
	m.addtotal_price = nil
}

// SetCompleted sets the "completed" field.
func (m *CheckoutMutation) SetCompleted(b bool) {
	m.completed = &b
}

// Completed returns the value of the "completed" field in the mutation.
func (m *CheckoutMutation) Completed() (r bool, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old "completed" field's value of the Checkout entity.
// If the Checkout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutMutation) OldCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ResetCompleted resets all changes to the "completed" field.
func (m *CheckoutMutation) ResetCompleted() {
	m.completed = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CheckoutMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CheckoutMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Checkout entity.
// If the Checkout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CheckoutMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CheckoutMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CheckoutMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Checkout entity.
// If the Checkout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CheckoutMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CheckoutMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CheckoutMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Checkout entity.
// If the Checkout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CheckoutMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[checkout.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CheckoutMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[checkout.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CheckoutMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, checkout.FieldDeletedAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CheckoutMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CheckoutMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CheckoutMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CheckoutMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CheckoutMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CheckoutMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetLocationID sets the "location" edge to the UserLocation entity by id.
func (m *CheckoutMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the UserLocation entity.
func (m *CheckoutMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the UserLocation entity was cleared.
func (m *CheckoutMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *CheckoutMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *CheckoutMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *CheckoutMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetCartID sets the "cart" edge to the Cart entity by id.
func (m *CheckoutMutation) SetCartID(id int) {
	m.cart = &id
}

// ClearCart clears the "cart" edge to the Cart entity.
func (m *CheckoutMutation) ClearCart() {
	m.clearedcart = true
}

// CartCleared reports if the "cart" edge to the Cart entity was cleared.
func (m *CheckoutMutation) CartCleared() bool {
	return m.clearedcart
}

// CartID returns the "cart" edge ID in the mutation.
func (m *CheckoutMutation) CartID() (id int, exists bool) {
	if m.cart != nil {
		return *m.cart, true
	}
	return
}

// CartIDs returns the "cart" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CartID instead. It exists only for internal usage by the builders.
func (m *CheckoutMutation) CartIDs() (ids []int) {
	if id := m.cart; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCart resets all changes to the "cart" edge.
func (m *CheckoutMutation) ResetCart() {
	m.cart = nil
	m.clearedcart = false
}

// AddCheckoutProductIDs adds the "checkout_products" edge to the CheckoutProduct entity by ids.
func (m *CheckoutMutation) AddCheckoutProductIDs(ids ...int) {
	if m.checkout_products == nil {
		m.checkout_products = make(map[int]struct{})
	}
	for i := range ids {
		m.checkout_products[ids[i]] = struct{}{}
	}
}

// ClearCheckoutProducts clears the "checkout_products" edge to the CheckoutProduct entity.
func (m *CheckoutMutation) ClearCheckoutProducts() {
	m.clearedcheckout_products = true
}

// CheckoutProductsCleared reports if the "checkout_products" edge to the CheckoutProduct entity was cleared.
func (m *CheckoutMutation) CheckoutProductsCleared() bool {
	return m.clearedcheckout_products
}

// RemoveCheckoutProductIDs removes the "checkout_products" edge to the CheckoutProduct entity by IDs.
func (m *CheckoutMutation) RemoveCheckoutProductIDs(ids ...int) {
	if m.removedcheckout_products == nil {
		m.removedcheckout_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.checkout_products, ids[i])
		m.removedcheckout_products[ids[i]] = struct{}{}
	}
}

// RemovedCheckoutProducts returns the removed IDs of the "checkout_products" edge to the CheckoutProduct entity.
func (m *CheckoutMutation) RemovedCheckoutProductsIDs() (ids []int) {
	for id := range m.removedcheckout_products {
		ids = append(ids, id)
	}
	return
}

// CheckoutProductsIDs returns the "checkout_products" edge IDs in the mutation.
func (m *CheckoutMutation) CheckoutProductsIDs() (ids []int) {
	for id := range m.checkout_products {
		ids = append(ids, id)
	}
	return
}

// ResetCheckoutProducts resets all changes to the "checkout_products" edge.
func (m *CheckoutMutation) ResetCheckoutProducts() {
	m.checkout_products = nil
	m.clearedcheckout_products = false
	m.removedcheckout_products = nil
}

// Where appends a list predicates to the CheckoutMutation builder.
func (m *CheckoutMutation) Where(ps ...predicate.Checkout) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CheckoutMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Checkout).
func (m *CheckoutMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CheckoutMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.total_price != nil {
		fields = append(fields, checkout.FieldTotalPrice)
	}
	if m.completed != nil {
		fields = append(fields, checkout.FieldCompleted)
	}
	if m.created_at != nil {
		fields = append(fields, checkout.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, checkout.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, checkout.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CheckoutMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case checkout.FieldTotalPrice:
		return m.TotalPrice()
	case checkout.FieldCompleted:
		return m.Completed()
	case checkout.FieldCreatedAt:
		return m.CreatedAt()
	case checkout.FieldUpdatedAt:
		return m.UpdatedAt()
	case checkout.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CheckoutMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case checkout.FieldTotalPrice:
		return m.OldTotalPrice(ctx)
	case checkout.FieldCompleted:
		return m.OldCompleted(ctx)
	case checkout.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case checkout.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case checkout.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Checkout field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckoutMutation) SetField(name string, value ent.Value) error {
	switch name {
	case checkout.FieldTotalPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPrice(v)
		return nil
	case checkout.FieldCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	case checkout.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case checkout.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case checkout.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Checkout field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CheckoutMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_price != nil {
		fields = append(fields, checkout.FieldTotalPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CheckoutMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case checkout.FieldTotalPrice:
		return m.AddedTotalPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckoutMutation) AddField(name string, value ent.Value) error {
	switch name {
	case checkout.FieldTotalPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Checkout numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CheckoutMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(checkout.FieldDeletedAt) {
		fields = append(fields, checkout.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CheckoutMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckoutMutation) ClearField(name string) error {
	switch name {
	case checkout.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Checkout nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CheckoutMutation) ResetField(name string) error {
	switch name {
	case checkout.FieldTotalPrice:
		m.ResetTotalPrice()
		return nil
	case checkout.FieldCompleted:
		m.ResetCompleted()
		return nil
	case checkout.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case checkout.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case checkout.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Checkout field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CheckoutMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, checkout.EdgeUser)
	}
	if m.location != nil {
		edges = append(edges, checkout.EdgeLocation)
	}
	if m.cart != nil {
		edges = append(edges, checkout.EdgeCart)
	}
	if m.checkout_products != nil {
		edges = append(edges, checkout.EdgeCheckoutProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CheckoutMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case checkout.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case checkout.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case checkout.EdgeCart:
		if id := m.cart; id != nil {
			return []ent.Value{*id}
		}
	case checkout.EdgeCheckoutProducts:
		ids := make([]ent.Value, 0, len(m.checkout_products))
		for id := range m.checkout_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CheckoutMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcheckout_products != nil {
		edges = append(edges, checkout.EdgeCheckoutProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CheckoutMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case checkout.EdgeCheckoutProducts:
		ids := make([]ent.Value, 0, len(m.removedcheckout_products))
		for id := range m.removedcheckout_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CheckoutMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, checkout.EdgeUser)
	}
	if m.clearedlocation {
		edges = append(edges, checkout.EdgeLocation)
	}
	if m.clearedcart {
		edges = append(edges, checkout.EdgeCart)
	}
	if m.clearedcheckout_products {
		edges = append(edges, checkout.EdgeCheckoutProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CheckoutMutation) EdgeCleared(name string) bool {
	switch name {
	case checkout.EdgeUser:
		return m.cleareduser
	case checkout.EdgeLocation:
		return m.clearedlocation
	case checkout.EdgeCart:
		return m.clearedcart
	case checkout.EdgeCheckoutProducts:
		return m.clearedcheckout_products
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CheckoutMutation) ClearEdge(name string) error {
	switch name {
	case checkout.EdgeUser:
		m.ClearUser()
		return nil
	case checkout.EdgeLocation:
		m.ClearLocation()
		return nil
	case checkout.EdgeCart:
		m.ClearCart()
		return nil
	}
	return fmt.Errorf("unknown Checkout unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CheckoutMutation) ResetEdge(name string) error {
	switch name {
	case checkout.EdgeUser:
		m.ResetUser()
		return nil
	case checkout.EdgeLocation:
		m.ResetLocation()
		return nil
	case checkout.EdgeCart:
		m.ResetCart()
		return nil
	case checkout.EdgeCheckoutProducts:
		m.ResetCheckoutProducts()
		return nil
	}
	return fmt.Errorf("unknown Checkout edge %s", name)
}

// CheckoutProductMutation represents an operation that mutates the CheckoutProduct nodes in the graph.
type CheckoutProductMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	quantity                        *int
	addquantity                     *int
	selling_price                   *decimal.Decimal
	addselling_price                *decimal.Decimal
	offer_price                     *int
	addoffer_price                  *int
	received                        *bool
	status                          *int
	addstatus                       *int
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	clearedFields                   map[string]struct{}
	user                            *int
	cleareduser                     bool
	checkout                        *int
	clearedcheckout                 bool
	seller                          *int
	clearedseller                   bool
	seller_product                  *int
	clearedseller_product           bool
	seller_product_variation        *int
	clearedseller_product_variation bool
	done                            bool
	oldValue                        func(context.Context) (*CheckoutProduct, error)
	predicates                      []predicate.CheckoutProduct
}

var _ ent.Mutation = (*CheckoutProductMutation)(nil)

// checkoutproductOption allows management of the mutation configuration using functional options.
type checkoutproductOption func(*CheckoutProductMutation)

// newCheckoutProductMutation creates new mutation for the CheckoutProduct entity.
func newCheckoutProductMutation(c config, op Op, opts ...checkoutproductOption) *CheckoutProductMutation {
	m := &CheckoutProductMutation{
		config:        c,
		op:            op,
		typ:           TypeCheckoutProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckoutProductID sets the ID field of the mutation.
func withCheckoutProductID(id int) checkoutproductOption {
	return func(m *CheckoutProductMutation) {
		var (
			err   error
			once  sync.Once
			value *CheckoutProduct
		)
		m.oldValue = func(ctx context.Context) (*CheckoutProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CheckoutProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheckoutProduct sets the old CheckoutProduct of the mutation.
func withCheckoutProduct(node *CheckoutProduct) checkoutproductOption {
	return func(m *CheckoutProductMutation) {
		m.oldValue = func(context.Context) (*CheckoutProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckoutProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckoutProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CheckoutProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CheckoutProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CheckoutProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *CheckoutProductMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *CheckoutProductMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the CheckoutProduct entity.
// If the CheckoutProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutProductMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *CheckoutProductMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *CheckoutProductMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *CheckoutProductMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetSellingPrice sets the "selling_price" field.
func (m *CheckoutProductMutation) SetSellingPrice(d decimal.Decimal) {
	m.selling_price = &d
	m.addselling_price = nil
}

// SellingPrice returns the value of the "selling_price" field in the mutation.
func (m *CheckoutProductMutation) SellingPrice() (r decimal.Decimal, exists bool) {
	v := m.selling_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSellingPrice returns the old "selling_price" field's value of the CheckoutProduct entity.
// If the CheckoutProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutProductMutation) OldSellingPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellingPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellingPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellingPrice: %w", err)
	}
	return oldValue.SellingPrice, nil
}

// AddSellingPrice adds d to the "selling_price" field.
func (m *CheckoutProductMutation) AddSellingPrice(d decimal.Decimal) {
	if m.addselling_price != nil {
		*m.addselling_price = m.addselling_price.Add(d)
	} else {
		m.addselling_price = &d
	}
}

// AddedSellingPrice returns the value that was added to the "selling_price" field in this mutation.
func (m *CheckoutProductMutation) AddedSellingPrice() (r decimal.Decimal, exists bool) {
	v := m.addselling_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetSellingPrice resets all changes to the "selling_price" field.
func (m *CheckoutProductMutation) ResetSellingPrice() {
	m.selling_price = nil
	m.addselling_price = nil
}

// SetOfferPrice sets the "offer_price" field.
func (m *CheckoutProductMutation) SetOfferPrice(i int) {
	m.offer_price = &i
	m.addoffer_price = nil
}

// OfferPrice returns the value of the "offer_price" field in the mutation.
func (m *CheckoutProductMutation) OfferPrice() (r int, exists bool) {
	v := m.offer_price
	if v == nil {
		return
	}
	return *v, true
}

// OldOfferPrice returns the old "offer_price" field's value of the CheckoutProduct entity.
// If the CheckoutProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutProductMutation) OldOfferPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfferPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfferPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfferPrice: %w", err)
	}
	return oldValue.OfferPrice, nil
}

// AddOfferPrice adds i to the "offer_price" field.
func (m *CheckoutProductMutation) AddOfferPrice(i int) {
	if m.addoffer_price != nil {
		*m.addoffer_price += i
	} else {
		m.addoffer_price = &i
	}
}

// AddedOfferPrice returns the value that was added to the "offer_price" field in this mutation.
func (m *CheckoutProductMutation) AddedOfferPrice() (r int, exists bool) {
	v := m.addoffer_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetOfferPrice resets all changes to the "offer_price" field.
func (m *CheckoutProductMutation) ResetOfferPrice() {
	m.offer_price = nil
	m.addoffer_price = nil
}

// SetReceived sets the "received" field.
func (m *CheckoutProductMutation) SetReceived(b bool) {
	m.received = &b
}

// Received returns the value of the "received" field in the mutation.
func (m *CheckoutProductMutation) Received() (r bool, exists bool) {
	v := m.received
	if v == nil {
		return
	}
	return *v, true
}

// OldReceived returns the old "received" field's value of the CheckoutProduct entity.
// If the CheckoutProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutProductMutation) OldReceived(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceived: %w", err)
	}
	return oldValue.Received, nil
}

// ResetReceived resets all changes to the "received" field.
func (m *CheckoutProductMutation) ResetReceived() {
	m.received = nil
}

// SetStatus sets the "status" field.
func (m *CheckoutProductMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CheckoutProductMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CheckoutProduct entity.
// If the CheckoutProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutProductMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CheckoutProductMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CheckoutProductMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CheckoutProductMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CheckoutProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CheckoutProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CheckoutProduct entity.
// If the CheckoutProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CheckoutProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CheckoutProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CheckoutProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CheckoutProduct entity.
// If the CheckoutProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CheckoutProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CheckoutProductMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CheckoutProductMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CheckoutProduct entity.
// If the CheckoutProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutProductMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CheckoutProductMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[checkoutproduct.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CheckoutProductMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[checkoutproduct.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CheckoutProductMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, checkoutproduct.FieldDeletedAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CheckoutProductMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CheckoutProductMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CheckoutProductMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CheckoutProductMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CheckoutProductMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CheckoutProductMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetCheckoutID sets the "checkout" edge to the Checkout entity by id.
func (m *CheckoutProductMutation) SetCheckoutID(id int) {
	m.checkout = &id
}

// ClearCheckout clears the "checkout" edge to the Checkout entity.
func (m *CheckoutProductMutation) ClearCheckout() {
	m.clearedcheckout = true
}

// CheckoutCleared reports if the "checkout" edge to the Checkout entity was cleared.
func (m *CheckoutProductMutation) CheckoutCleared() bool {
	return m.clearedcheckout
}

// CheckoutID returns the "checkout" edge ID in the mutation.
func (m *CheckoutProductMutation) CheckoutID() (id int, exists bool) {
	if m.checkout != nil {
		return *m.checkout, true
	}
	return
}

// CheckoutIDs returns the "checkout" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CheckoutID instead. It exists only for internal usage by the builders.
func (m *CheckoutProductMutation) CheckoutIDs() (ids []int) {
	if id := m.checkout; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCheckout resets all changes to the "checkout" edge.
func (m *CheckoutProductMutation) ResetCheckout() {
	m.checkout = nil
	m.clearedcheckout = false
}

// SetSellerID sets the "seller" edge to the User entity by id.
func (m *CheckoutProductMutation) SetSellerID(id int) {
	m.seller = &id
}

// ClearSeller clears the "seller" edge to the User entity.
func (m *CheckoutProductMutation) ClearSeller() {
	m.clearedseller = true
}

// SellerCleared reports if the "seller" edge to the User entity was cleared.
func (m *CheckoutProductMutation) SellerCleared() bool {
	return m.clearedseller
}

// SellerID returns the "seller" edge ID in the mutation.
func (m *CheckoutProductMutation) SellerID() (id int, exists bool) {
	if m.seller != nil {
		return *m.seller, true
	}
	return
}

// SellerIDs returns the "seller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SellerID instead. It exists only for internal usage by the builders.
func (m *CheckoutProductMutation) SellerIDs() (ids []int) {
	if id := m.seller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeller resets all changes to the "seller" edge.
func (m *CheckoutProductMutation) ResetSeller() {
	m.seller = nil
	m.clearedseller = false
}

// SetSellerProductID sets the "seller_product" edge to the SellerProduct entity by id.
func (m *CheckoutProductMutation) SetSellerProductID(id int) {
	m.seller_product = &id
}

// ClearSellerProduct clears the "seller_product" edge to the SellerProduct entity.
func (m *CheckoutProductMutation) ClearSellerProduct() {
	m.clearedseller_product = true
}

// SellerProductCleared reports if the "seller_product" edge to the SellerProduct entity was cleared.
func (m *CheckoutProductMutation) SellerProductCleared() bool {
	return m.clearedseller_product
}

// SellerProductID returns the "seller_product" edge ID in the mutation.
func (m *CheckoutProductMutation) SellerProductID() (id int, exists bool) {
	if m.seller_product != nil {
		return *m.seller_product, true
	}
	return
}

// SellerProductIDs returns the "seller_product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SellerProductID instead. It exists only for internal usage by the builders.
func (m *CheckoutProductMutation) SellerProductIDs() (ids []int) {
	if id := m.seller_product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSellerProduct resets all changes to the "seller_product" edge.
func (m *CheckoutProductMutation) ResetSellerProduct() {
	m.seller_product = nil
	m.clearedseller_product = false
}

// SetSellerProductVariationID sets the "seller_product_variation" edge to the SellerProductVariation entity by id.
func (m *CheckoutProductMutation) SetSellerProductVariationID(id int) {
	m.seller_product_variation = &id
}

// ClearSellerProductVariation clears the "seller_product_variation" edge to the SellerProductVariation entity.
func (m *CheckoutProductMutation) ClearSellerProductVariation() {
	m.clearedseller_product_variation = true
}

// SellerProductVariationCleared reports if the "seller_product_variation" edge to the SellerProductVariation entity was cleared.
func (m *CheckoutProductMutation) SellerProductVariationCleared() bool {
	return m.clearedseller_product_variation
}

// SellerProductVariationID returns the "seller_product_variation" edge ID in the mutation.
func (m *CheckoutProductMutation) SellerProductVariationID() (id int, exists bool) {
	if m.seller_product_variation != nil {
		return *m.seller_product_variation, true
	}
	return
}

// SellerProductVariationIDs returns the "seller_product_variation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SellerProductVariationID instead. It exists only for internal usage by the builders.
func (m *CheckoutProductMutation) SellerProductVariationIDs() (ids []int) {
	if id := m.seller_product_variation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSellerProductVariation resets all changes to the "seller_product_variation" edge.
func (m *CheckoutProductMutation) ResetSellerProductVariation() {
	m.seller_product_variation = nil
	m.clearedseller_product_variation = false
}

// Where appends a list predicates to the CheckoutProductMutation builder.
func (m *CheckoutProductMutation) Where(ps ...predicate.CheckoutProduct) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CheckoutProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CheckoutProduct).
func (m *CheckoutProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CheckoutProductMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.quantity != nil {
		fields = append(fields, checkoutproduct.FieldQuantity)
	}
	if m.selling_price != nil {
		fields = append(fields, checkoutproduct.FieldSellingPrice)
	}
	if m.offer_price != nil {
		fields = append(fields, checkoutproduct.FieldOfferPrice)
	}
	if m.received != nil {
		fields = append(fields, checkoutproduct.FieldReceived)
	}
	if m.status != nil {
		fields = append(fields, checkoutproduct.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, checkoutproduct.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, checkoutproduct.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, checkoutproduct.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CheckoutProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case checkoutproduct.FieldQuantity:
		return m.Quantity()
	case checkoutproduct.FieldSellingPrice:
		return m.SellingPrice()
	case checkoutproduct.FieldOfferPrice:
		return m.OfferPrice()
	case checkoutproduct.FieldReceived:
		return m.Received()
	case checkoutproduct.FieldStatus:
		return m.Status()
	case checkoutproduct.FieldCreatedAt:
		return m.CreatedAt()
	case checkoutproduct.FieldUpdatedAt:
		return m.UpdatedAt()
	case checkoutproduct.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CheckoutProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case checkoutproduct.FieldQuantity:
		return m.OldQuantity(ctx)
	case checkoutproduct.FieldSellingPrice:
		return m.OldSellingPrice(ctx)
	case checkoutproduct.FieldOfferPrice:
		return m.OldOfferPrice(ctx)
	case checkoutproduct.FieldReceived:
		return m.OldReceived(ctx)
	case checkoutproduct.FieldStatus:
		return m.OldStatus(ctx)
	case checkoutproduct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case checkoutproduct.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case checkoutproduct.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CheckoutProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckoutProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case checkoutproduct.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case checkoutproduct.FieldSellingPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellingPrice(v)
		return nil
	case checkoutproduct.FieldOfferPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfferPrice(v)
		return nil
	case checkoutproduct.FieldReceived:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceived(v)
		return nil
	case checkoutproduct.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case checkoutproduct.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case checkoutproduct.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case checkoutproduct.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CheckoutProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CheckoutProductMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, checkoutproduct.FieldQuantity)
	}
	if m.addselling_price != nil {
		fields = append(fields, checkoutproduct.FieldSellingPrice)
	}
	if m.addoffer_price != nil {
		fields = append(fields, checkoutproduct.FieldOfferPrice)
	}
	if m.addstatus != nil {
		fields = append(fields, checkoutproduct.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CheckoutProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case checkoutproduct.FieldQuantity:
		return m.AddedQuantity()
	case checkoutproduct.FieldSellingPrice:
		return m.AddedSellingPrice()
	case checkoutproduct.FieldOfferPrice:
		return m.AddedOfferPrice()
	case checkoutproduct.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckoutProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case checkoutproduct.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case checkoutproduct.FieldSellingPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSellingPrice(v)
		return nil
	case checkoutproduct.FieldOfferPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOfferPrice(v)
		return nil
	case checkoutproduct.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CheckoutProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CheckoutProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(checkoutproduct.FieldDeletedAt) {
		fields = append(fields, checkoutproduct.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CheckoutProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckoutProductMutation) ClearField(name string) error {
	switch name {
	case checkoutproduct.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CheckoutProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CheckoutProductMutation) ResetField(name string) error {
	switch name {
	case checkoutproduct.FieldQuantity:
		m.ResetQuantity()
		return nil
	case checkoutproduct.FieldSellingPrice:
		m.ResetSellingPrice()
		return nil
	case checkoutproduct.FieldOfferPrice:
		m.ResetOfferPrice()
		return nil
	case checkoutproduct.FieldReceived:
		m.ResetReceived()
		return nil
	case checkoutproduct.FieldStatus:
		m.ResetStatus()
		return nil
	case checkoutproduct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case checkoutproduct.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case checkoutproduct.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CheckoutProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CheckoutProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, checkoutproduct.EdgeUser)
	}
	if m.checkout != nil {
		edges = append(edges, checkoutproduct.EdgeCheckout)
	}
	if m.seller != nil {
		edges = append(edges, checkoutproduct.EdgeSeller)
	}
	if m.seller_product != nil {
		edges = append(edges, checkoutproduct.EdgeSellerProduct)
	}
	if m.seller_product_variation != nil {
		edges = append(edges, checkoutproduct.EdgeSellerProductVariation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CheckoutProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case checkoutproduct.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case checkoutproduct.EdgeCheckout:
		if id := m.checkout; id != nil {
			return []ent.Value{*id}
		}
	case checkoutproduct.EdgeSeller:
		if id := m.seller; id != nil {
			return []ent.Value{*id}
		}
	case checkoutproduct.EdgeSellerProduct:
		if id := m.seller_product; id != nil {
			return []ent.Value{*id}
		}
	case checkoutproduct.EdgeSellerProductVariation:
		if id := m.seller_product_variation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CheckoutProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CheckoutProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CheckoutProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, checkoutproduct.EdgeUser)
	}
	if m.clearedcheckout {
		edges = append(edges, checkoutproduct.EdgeCheckout)
	}
	if m.clearedseller {
		edges = append(edges, checkoutproduct.EdgeSeller)
	}
	if m.clearedseller_product {
		edges = append(edges, checkoutproduct.EdgeSellerProduct)
	}
	if m.clearedseller_product_variation {
		edges = append(edges, checkoutproduct.EdgeSellerProductVariation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CheckoutProductMutation) EdgeCleared(name string) bool {
	switch name {
	case checkoutproduct.EdgeUser:
		return m.cleareduser
	case checkoutproduct.EdgeCheckout:
		return m.clearedcheckout
	case checkoutproduct.EdgeSeller:
		return m.clearedseller
	case checkoutproduct.EdgeSellerProduct:
		return m.clearedseller_product
	case checkoutproduct.EdgeSellerProductVariation:
		return m.clearedseller_product_variation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CheckoutProductMutation) ClearEdge(name string) error {
	switch name {
	case checkoutproduct.EdgeUser:
		m.ClearUser()
		return nil
	case checkoutproduct.EdgeCheckout:
		m.ClearCheckout()
		return nil
	case checkoutproduct.EdgeSeller:
		m.ClearSeller()
		return nil
	case checkoutproduct.EdgeSellerProduct:
		m.ClearSellerProduct()
		return nil
	case checkoutproduct.EdgeSellerProductVariation:
		m.ClearSellerProductVariation()
		return nil
	}
	return fmt.Errorf("unknown CheckoutProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CheckoutProductMutation) ResetEdge(name string) error {
	switch name {
	case checkoutproduct.EdgeUser:
		m.ResetUser()
		return nil
	case checkoutproduct.EdgeCheckout:
		m.ResetCheckout()
		return nil
	case checkoutproduct.EdgeSeller:
		m.ResetSeller()
		return nil
	case checkoutproduct.EdgeSellerProduct:
		m.ResetSellerProduct()
		return nil
	case checkoutproduct.EdgeSellerProductVariation:
		m.ResetSellerProductVariation()
		return nil
	}
	return fmt.Errorf("unknown CheckoutProduct edge %s", name)
}

// SellerProductMutation represents an operation that mutates the SellerProduct nodes in the graph.
type SellerProductMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	name                             *string
	slug                             *string
	selling_price                    *decimal.Decimal
	addselling_price                 *decimal.Decimal
	product_price                    *decimal.Decimal
	addproduct_price                 *decimal.Decimal
	quantity                         *int
	addquantity                      *int
	active                           *bool
	description                      *string
	offer_price                      *int
	addoffer_price                   *int
	offer_price_start                *time.Time
	offer_price_end                  *time.Time
	next_stock                       *time.Time
	created_at                       *time.Time
	updated_at                       *time.Time
	deleted_at                       *time.Time
	clearedFields                    map[string]struct{}
	brand                            *int
	clearedbrand                     bool
	user                             *int
	cleareduser                      bool
	seller_product_images            map[int]struct{}
	removedseller_product_images     map[int]struct{}
	clearedseller_product_images     bool
	categories                       map[int]struct{}
	removedcategories                map[int]struct{}
	clearedcategories                bool
	shop                             *int
	clearedshop                      bool
	cart_products                    map[int]struct{}
	removedcart_products             map[int]struct{}
	clearedcart_products             bool
	checkout_products                map[int]struct{}
	removedcheckout_products         map[int]struct{}
	clearedcheckout_products         bool
	seller_product_variations        map[int]struct{}
	removedseller_product_variations map[int]struct{}
	clearedseller_product_variations bool
	done                             bool
	oldValue                         func(context.Context) (*SellerProduct, error)
	predicates                       []predicate.SellerProduct
}

var _ ent.Mutation = (*SellerProductMutation)(nil)

// sellerproductOption allows management of the mutation configuration using functional options.
type sellerproductOption func(*SellerProductMutation)

// newSellerProductMutation creates new mutation for the SellerProduct entity.
func newSellerProductMutation(c config, op Op, opts ...sellerproductOption) *SellerProductMutation {
	m := &SellerProductMutation{
		config:        c,
		op:            op,
		typ:           TypeSellerProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSellerProductID sets the ID field of the mutation.
func withSellerProductID(id int) sellerproductOption {
	return func(m *SellerProductMutation) {
		var (
			err   error
			once  sync.Once
			value *SellerProduct
		)
		m.oldValue = func(ctx context.Context) (*SellerProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SellerProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSellerProduct sets the old SellerProduct of the mutation.
func withSellerProduct(node *SellerProduct) sellerproductOption {
	return func(m *SellerProductMutation) {
		m.oldValue = func(context.Context) (*SellerProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SellerProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SellerProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SellerProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SellerProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SellerProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SellerProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SellerProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SellerProductMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *SellerProductMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *SellerProductMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *SellerProductMutation) ResetSlug() {
	m.slug = nil
}

// SetSellingPrice sets the "selling_price" field.
func (m *SellerProductMutation) SetSellingPrice(d decimal.Decimal) {
	m.selling_price = &d
	m.addselling_price = nil
}

// SellingPrice returns the value of the "selling_price" field in the mutation.
func (m *SellerProductMutation) SellingPrice() (r decimal.Decimal, exists bool) {
	v := m.selling_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSellingPrice returns the old "selling_price" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldSellingPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellingPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellingPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellingPrice: %w", err)
	}
	return oldValue.SellingPrice, nil
}

// AddSellingPrice adds d to the "selling_price" field.
func (m *SellerProductMutation) AddSellingPrice(d decimal.Decimal) {
	if m.addselling_price != nil {
		*m.addselling_price = m.addselling_price.Add(d)
	} else {
		m.addselling_price = &d
	}
}

// AddedSellingPrice returns the value that was added to the "selling_price" field in this mutation.
func (m *SellerProductMutation) AddedSellingPrice() (r decimal.Decimal, exists bool) {
	v := m.addselling_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetSellingPrice resets all changes to the "selling_price" field.
func (m *SellerProductMutation) ResetSellingPrice() {
	m.selling_price = nil
	m.addselling_price = nil
}

// SetProductPrice sets the "product_price" field.
func (m *SellerProductMutation) SetProductPrice(d decimal.Decimal) {
	m.product_price = &d
	m.addproduct_price = nil
}

// ProductPrice returns the value of the "product_price" field in the mutation.
func (m *SellerProductMutation) ProductPrice() (r decimal.Decimal, exists bool) {
	v := m.product_price
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPrice returns the old "product_price" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldProductPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPrice: %w", err)
	}
	return oldValue.ProductPrice, nil
}

// AddProductPrice adds d to the "product_price" field.
func (m *SellerProductMutation) AddProductPrice(d decimal.Decimal) {
	if m.addproduct_price != nil {
		*m.addproduct_price = m.addproduct_price.Add(d)
	} else {
		m.addproduct_price = &d
	}
}

// AddedProductPrice returns the value that was added to the "product_price" field in this mutation.
func (m *SellerProductMutation) AddedProductPrice() (r decimal.Decimal, exists bool) {
	v := m.addproduct_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductPrice resets all changes to the "product_price" field.
func (m *SellerProductMutation) ResetProductPrice() {
	m.product_price = nil
	m.addproduct_price = nil
}

// SetQuantity sets the "quantity" field.
func (m *SellerProductMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *SellerProductMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *SellerProductMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *SellerProductMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *SellerProductMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetActive sets the "active" field.
func (m *SellerProductMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *SellerProductMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *SellerProductMutation) ResetActive() {
	m.active = nil
}

// SetDescription sets the "description" field.
func (m *SellerProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SellerProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SellerProductMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[sellerproduct.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SellerProductMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[sellerproduct.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SellerProductMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, sellerproduct.FieldDescription)
}

// SetOfferPrice sets the "offer_price" field.
func (m *SellerProductMutation) SetOfferPrice(i int) {
	m.offer_price = &i
	m.addoffer_price = nil
}

// OfferPrice returns the value of the "offer_price" field in the mutation.
func (m *SellerProductMutation) OfferPrice() (r int, exists bool) {
	v := m.offer_price
	if v == nil {
		return
	}
	return *v, true
}

// OldOfferPrice returns the old "offer_price" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldOfferPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfferPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfferPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfferPrice: %w", err)
	}
	return oldValue.OfferPrice, nil
}

// AddOfferPrice adds i to the "offer_price" field.
func (m *SellerProductMutation) AddOfferPrice(i int) {
	if m.addoffer_price != nil {
		*m.addoffer_price += i
	} else {
		m.addoffer_price = &i
	}
}

// AddedOfferPrice returns the value that was added to the "offer_price" field in this mutation.
func (m *SellerProductMutation) AddedOfferPrice() (r int, exists bool) {
	v := m.addoffer_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetOfferPrice resets all changes to the "offer_price" field.
func (m *SellerProductMutation) ResetOfferPrice() {
	m.offer_price = nil
	m.addoffer_price = nil
}

// SetOfferPriceStart sets the "offer_price_start" field.
func (m *SellerProductMutation) SetOfferPriceStart(t time.Time) {
	m.offer_price_start = &t
}

// OfferPriceStart returns the value of the "offer_price_start" field in the mutation.
func (m *SellerProductMutation) OfferPriceStart() (r time.Time, exists bool) {
	v := m.offer_price_start
	if v == nil {
		return
	}
	return *v, true
}

// OldOfferPriceStart returns the old "offer_price_start" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldOfferPriceStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfferPriceStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfferPriceStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfferPriceStart: %w", err)
	}
	return oldValue.OfferPriceStart, nil
}

// ClearOfferPriceStart clears the value of the "offer_price_start" field.
func (m *SellerProductMutation) ClearOfferPriceStart() {
	m.offer_price_start = nil
	m.clearedFields[sellerproduct.FieldOfferPriceStart] = struct{}{}
}

// OfferPriceStartCleared returns if the "offer_price_start" field was cleared in this mutation.
func (m *SellerProductMutation) OfferPriceStartCleared() bool {
	_, ok := m.clearedFields[sellerproduct.FieldOfferPriceStart]
	return ok
}

// ResetOfferPriceStart resets all changes to the "offer_price_start" field.
func (m *SellerProductMutation) ResetOfferPriceStart() {
	m.offer_price_start = nil
	delete(m.clearedFields, sellerproduct.FieldOfferPriceStart)
}

// SetOfferPriceEnd sets the "offer_price_end" field.
func (m *SellerProductMutation) SetOfferPriceEnd(t time.Time) {
	m.offer_price_end = &t
}

// OfferPriceEnd returns the value of the "offer_price_end" field in the mutation.
func (m *SellerProductMutation) OfferPriceEnd() (r time.Time, exists bool) {
	v := m.offer_price_end
	if v == nil {
		return
	}
	return *v, true
}

// OldOfferPriceEnd returns the old "offer_price_end" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldOfferPriceEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfferPriceEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfferPriceEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfferPriceEnd: %w", err)
	}
	return oldValue.OfferPriceEnd, nil
}

// ClearOfferPriceEnd clears the value of the "offer_price_end" field.
func (m *SellerProductMutation) ClearOfferPriceEnd() {
	m.offer_price_end = nil
	m.clearedFields[sellerproduct.FieldOfferPriceEnd] = struct{}{}
}

// OfferPriceEndCleared returns if the "offer_price_end" field was cleared in this mutation.
func (m *SellerProductMutation) OfferPriceEndCleared() bool {
	_, ok := m.clearedFields[sellerproduct.FieldOfferPriceEnd]
	return ok
}

// ResetOfferPriceEnd resets all changes to the "offer_price_end" field.
func (m *SellerProductMutation) ResetOfferPriceEnd() {
	m.offer_price_end = nil
	delete(m.clearedFields, sellerproduct.FieldOfferPriceEnd)
}

// SetNextStock sets the "next_stock" field.
func (m *SellerProductMutation) SetNextStock(t time.Time) {
	m.next_stock = &t
}

// NextStock returns the value of the "next_stock" field in the mutation.
func (m *SellerProductMutation) NextStock() (r time.Time, exists bool) {
	v := m.next_stock
	if v == nil {
		return
	}
	return *v, true
}

// OldNextStock returns the old "next_stock" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldNextStock(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextStock: %w", err)
	}
	return oldValue.NextStock, nil
}

// ClearNextStock clears the value of the "next_stock" field.
func (m *SellerProductMutation) ClearNextStock() {
	m.next_stock = nil
	m.clearedFields[sellerproduct.FieldNextStock] = struct{}{}
}

// NextStockCleared returns if the "next_stock" field was cleared in this mutation.
func (m *SellerProductMutation) NextStockCleared() bool {
	_, ok := m.clearedFields[sellerproduct.FieldNextStock]
	return ok
}

// ResetNextStock resets all changes to the "next_stock" field.
func (m *SellerProductMutation) ResetNextStock() {
	m.next_stock = nil
	delete(m.clearedFields, sellerproduct.FieldNextStock)
}

// SetCreatedAt sets the "created_at" field.
func (m *SellerProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SellerProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SellerProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SellerProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SellerProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SellerProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SellerProductMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SellerProductMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SellerProduct entity.
// If the SellerProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SellerProductMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sellerproduct.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SellerProductMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sellerproduct.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SellerProductMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sellerproduct.FieldDeletedAt)
}

// SetBrandID sets the "brand" edge to the Brand entity by id.
func (m *SellerProductMutation) SetBrandID(id int) {
	m.brand = &id
}

// ClearBrand clears the "brand" edge to the Brand entity.
func (m *SellerProductMutation) ClearBrand() {
	m.clearedbrand = true
}

// BrandCleared reports if the "brand" edge to the Brand entity was cleared.
func (m *SellerProductMutation) BrandCleared() bool {
	return m.clearedbrand
}

// BrandID returns the "brand" edge ID in the mutation.
func (m *SellerProductMutation) BrandID() (id int, exists bool) {
	if m.brand != nil {
		return *m.brand, true
	}
	return
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *SellerProductMutation) BrandIDs() (ids []int) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *SellerProductMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SellerProductMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SellerProductMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SellerProductMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SellerProductMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SellerProductMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SellerProductMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddSellerProductImageIDs adds the "seller_product_images" edge to the SellerProductImage entity by ids.
func (m *SellerProductMutation) AddSellerProductImageIDs(ids ...int) {
	if m.seller_product_images == nil {
		m.seller_product_images = make(map[int]struct{})
	}
	for i := range ids {
		m.seller_product_images[ids[i]] = struct{}{}
	}
}

// ClearSellerProductImages clears the "seller_product_images" edge to the SellerProductImage entity.
func (m *SellerProductMutation) ClearSellerProductImages() {
	m.clearedseller_product_images = true
}

// SellerProductImagesCleared reports if the "seller_product_images" edge to the SellerProductImage entity was cleared.
func (m *SellerProductMutation) SellerProductImagesCleared() bool {
	return m.clearedseller_product_images
}

// RemoveSellerProductImageIDs removes the "seller_product_images" edge to the SellerProductImage entity by IDs.
func (m *SellerProductMutation) RemoveSellerProductImageIDs(ids ...int) {
	if m.removedseller_product_images == nil {
		m.removedseller_product_images = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seller_product_images, ids[i])
		m.removedseller_product_images[ids[i]] = struct{}{}
	}
}

// RemovedSellerProductImages returns the removed IDs of the "seller_product_images" edge to the SellerProductImage entity.
func (m *SellerProductMutation) RemovedSellerProductImagesIDs() (ids []int) {
	for id := range m.removedseller_product_images {
		ids = append(ids, id)
	}
	return
}

// SellerProductImagesIDs returns the "seller_product_images" edge IDs in the mutation.
func (m *SellerProductMutation) SellerProductImagesIDs() (ids []int) {
	for id := range m.seller_product_images {
		ids = append(ids, id)
	}
	return
}

// ResetSellerProductImages resets all changes to the "seller_product_images" edge.
func (m *SellerProductMutation) ResetSellerProductImages() {
	m.seller_product_images = nil
	m.clearedseller_product_images = false
	m.removedseller_product_images = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *SellerProductMutation) AddCategoryIDs(ids ...int) {
	if m.categories == nil {
		m.categories = make(map[int]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *SellerProductMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *SellerProductMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *SellerProductMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *SellerProductMutation) RemovedCategoriesIDs() (ids []int) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *SellerProductMutation) CategoriesIDs() (ids []int) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *SellerProductMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// SetShopID sets the "shop" edge to the SellerShop entity by id.
func (m *SellerProductMutation) SetShopID(id int) {
	m.shop = &id
}

// ClearShop clears the "shop" edge to the SellerShop entity.
func (m *SellerProductMutation) ClearShop() {
	m.clearedshop = true
}

// ShopCleared reports if the "shop" edge to the SellerShop entity was cleared.
func (m *SellerProductMutation) ShopCleared() bool {
	return m.clearedshop
}

// ShopID returns the "shop" edge ID in the mutation.
func (m *SellerProductMutation) ShopID() (id int, exists bool) {
	if m.shop != nil {
		return *m.shop, true
	}
	return
}

// ShopIDs returns the "shop" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShopID instead. It exists only for internal usage by the builders.
func (m *SellerProductMutation) ShopIDs() (ids []int) {
	if id := m.shop; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShop resets all changes to the "shop" edge.
func (m *SellerProductMutation) ResetShop() {
	m.shop = nil
	m.clearedshop = false
}

// AddCartProductIDs adds the "cart_products" edge to the CartProduct entity by ids.
func (m *SellerProductMutation) AddCartProductIDs(ids ...int) {
	if m.cart_products == nil {
		m.cart_products = make(map[int]struct{})
	}
	for i := range ids {
		m.cart_products[ids[i]] = struct{}{}
	}
}

// ClearCartProducts clears the "cart_products" edge to the CartProduct entity.
func (m *SellerProductMutation) ClearCartProducts() {
	m.clearedcart_products = true
}

// CartProductsCleared reports if the "cart_products" edge to the CartProduct entity was cleared.
func (m *SellerProductMutation) CartProductsCleared() bool {
	return m.clearedcart_products
}

// RemoveCartProductIDs removes the "cart_products" edge to the CartProduct entity by IDs.
func (m *SellerProductMutation) RemoveCartProductIDs(ids ...int) {
	if m.removedcart_products == nil {
		m.removedcart_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cart_products, ids[i])
		m.removedcart_products[ids[i]] = struct{}{}
	}
}

// RemovedCartProducts returns the removed IDs of the "cart_products" edge to the CartProduct entity.
func (m *SellerProductMutation) RemovedCartProductsIDs() (ids []int) {
	for id := range m.removedcart_products {
		ids = append(ids, id)
	}
	return
}

// CartProductsIDs returns the "cart_products" edge IDs in the mutation.
func (m *SellerProductMutation) CartProductsIDs() (ids []int) {
	for id := range m.cart_products {
		ids = append(ids, id)
	}
	return
}

// ResetCartProducts resets all changes to the "cart_products" edge.
func (m *SellerProductMutation) ResetCartProducts() {
	m.cart_products = nil
	m.clearedcart_products = false
	m.removedcart_products = nil
}

// AddCheckoutProductIDs adds the "checkout_products" edge to the CheckoutProduct entity by ids.
func (m *SellerProductMutation) AddCheckoutProductIDs(ids ...int) {
	if m.checkout_products == nil {
		m.checkout_products = make(map[int]struct{})
	}
	for i := range ids {
		m.checkout_products[ids[i]] = struct{}{}
	}
}

// ClearCheckoutProducts clears the "checkout_products" edge to the CheckoutProduct entity.
func (m *SellerProductMutation) ClearCheckoutProducts() {
	m.clearedcheckout_products = true
}

// CheckoutProductsCleared reports if the "checkout_products" edge to the CheckoutProduct entity was cleared.
func (m *SellerProductMutation) CheckoutProductsCleared() bool {
	return m.clearedcheckout_products
}

// RemoveCheckoutProductIDs removes the "checkout_products" edge to the CheckoutProduct entity by IDs.
func (m *SellerProductMutation) RemoveCheckoutProductIDs(ids ...int) {
	if m.removedcheckout_products == nil {
		m.removedcheckout_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.checkout_products, ids[i])
		m.removedcheckout_products[ids[i]] = struct{}{}
	}
}

// RemovedCheckoutProducts returns the removed IDs of the "checkout_products" edge to the CheckoutProduct entity.
func (m *SellerProductMutation) RemovedCheckoutProductsIDs() (ids []int) {
	for id := range m.removedcheckout_products {
		ids = append(ids, id)
	}
	return
}

// CheckoutProductsIDs returns the "checkout_products" edge IDs in the mutation.
func (m *SellerProductMutation) CheckoutProductsIDs() (ids []int) {
	for id := range m.checkout_products {
		ids = append(ids, id)
	}
	return
}

// ResetCheckoutProducts resets all changes to the "checkout_products" edge.
func (m *SellerProductMutation) ResetCheckoutProducts() {
	m.checkout_products = nil
	m.clearedcheckout_products = false
	m.removedcheckout_products = nil
}

// AddSellerProductVariationIDs adds the "seller_product_variations" edge to the SellerProductVariation entity by ids.
func (m *SellerProductMutation) AddSellerProductVariationIDs(ids ...int) {
	if m.seller_product_variations == nil {
		m.seller_product_variations = make(map[int]struct{})
	}
	for i := range ids {
		m.seller_product_variations[ids[i]] = struct{}{}
	}
}

// ClearSellerProductVariations clears the "seller_product_variations" edge to the SellerProductVariation entity.
func (m *SellerProductMutation) ClearSellerProductVariations() {
	m.clearedseller_product_variations = true
}

// SellerProductVariationsCleared reports if the "seller_product_variations" edge to the SellerProductVariation entity was cleared.
func (m *SellerProductMutation) SellerProductVariationsCleared() bool {
	return m.clearedseller_product_variations
}

// RemoveSellerProductVariationIDs removes the "seller_product_variations" edge to the SellerProductVariation entity by IDs.
func (m *SellerProductMutation) RemoveSellerProductVariationIDs(ids ...int) {
	if m.removedseller_product_variations == nil {
		m.removedseller_product_variations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seller_product_variations, ids[i])
		m.removedseller_product_variations[ids[i]] = struct{}{}
	}
}

// RemovedSellerProductVariations returns the removed IDs of the "seller_product_variations" edge to the SellerProductVariation entity.
func (m *SellerProductMutation) RemovedSellerProductVariationsIDs() (ids []int) {
	for id := range m.removedseller_product_variations {
		ids = append(ids, id)
	}
	return
}

// SellerProductVariationsIDs returns the "seller_product_variations" edge IDs in the mutation.
func (m *SellerProductMutation) SellerProductVariationsIDs() (ids []int) {
	for id := range m.seller_product_variations {
		ids = append(ids, id)
	}
	return
}

// ResetSellerProductVariations resets all changes to the "seller_product_variations" edge.
func (m *SellerProductMutation) ResetSellerProductVariations() {
	m.seller_product_variations = nil
	m.clearedseller_product_variations = false
	m.removedseller_product_variations = nil
}

// Where appends a list predicates to the SellerProductMutation builder.
func (m *SellerProductMutation) Where(ps ...predicate.SellerProduct) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SellerProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SellerProduct).
func (m *SellerProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SellerProductMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, sellerproduct.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, sellerproduct.FieldSlug)
	}
	if m.selling_price != nil {
		fields = append(fields, sellerproduct.FieldSellingPrice)
	}
	if m.product_price != nil {
		fields = append(fields, sellerproduct.FieldProductPrice)
	}
	if m.quantity != nil {
		fields = append(fields, sellerproduct.FieldQuantity)
	}
	if m.active != nil {
		fields = append(fields, sellerproduct.FieldActive)
	}
	if m.description != nil {
		fields = append(fields, sellerproduct.FieldDescription)
	}
	if m.offer_price != nil {
		fields = append(fields, sellerproduct.FieldOfferPrice)
	}
	if m.offer_price_start != nil {
		fields = append(fields, sellerproduct.FieldOfferPriceStart)
	}
	if m.offer_price_end != nil {
		fields = append(fields, sellerproduct.FieldOfferPriceEnd)
	}
	if m.next_stock != nil {
		fields = append(fields, sellerproduct.FieldNextStock)
	}
	if m.created_at != nil {
		fields = append(fields, sellerproduct.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sellerproduct.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sellerproduct.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SellerProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sellerproduct.FieldName:
		return m.Name()
	case sellerproduct.FieldSlug:
		return m.Slug()
	case sellerproduct.FieldSellingPrice:
		return m.SellingPrice()
	case sellerproduct.FieldProductPrice:
		return m.ProductPrice()
	case sellerproduct.FieldQuantity:
		return m.Quantity()
	case sellerproduct.FieldActive:
		return m.Active()
	case sellerproduct.FieldDescription:
		return m.Description()
	case sellerproduct.FieldOfferPrice:
		return m.OfferPrice()
	case sellerproduct.FieldOfferPriceStart:
		return m.OfferPriceStart()
	case sellerproduct.FieldOfferPriceEnd:
		return m.OfferPriceEnd()
	case sellerproduct.FieldNextStock:
		return m.NextStock()
	case sellerproduct.FieldCreatedAt:
		return m.CreatedAt()
	case sellerproduct.FieldUpdatedAt:
		return m.UpdatedAt()
	case sellerproduct.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SellerProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sellerproduct.FieldName:
		return m.OldName(ctx)
	case sellerproduct.FieldSlug:
		return m.OldSlug(ctx)
	case sellerproduct.FieldSellingPrice:
		return m.OldSellingPrice(ctx)
	case sellerproduct.FieldProductPrice:
		return m.OldProductPrice(ctx)
	case sellerproduct.FieldQuantity:
		return m.OldQuantity(ctx)
	case sellerproduct.FieldActive:
		return m.OldActive(ctx)
	case sellerproduct.FieldDescription:
		return m.OldDescription(ctx)
	case sellerproduct.FieldOfferPrice:
		return m.OldOfferPrice(ctx)
	case sellerproduct.FieldOfferPriceStart:
		return m.OldOfferPriceStart(ctx)
	case sellerproduct.FieldOfferPriceEnd:
		return m.OldOfferPriceEnd(ctx)
	case sellerproduct.FieldNextStock:
		return m.OldNextStock(ctx)
	case sellerproduct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sellerproduct.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sellerproduct.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SellerProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sellerproduct.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sellerproduct.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case sellerproduct.FieldSellingPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellingPrice(v)
		return nil
	case sellerproduct.FieldProductPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPrice(v)
		return nil
	case sellerproduct.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case sellerproduct.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case sellerproduct.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case sellerproduct.FieldOfferPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfferPrice(v)
		return nil
	case sellerproduct.FieldOfferPriceStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfferPriceStart(v)
		return nil
	case sellerproduct.FieldOfferPriceEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfferPriceEnd(v)
		return nil
	case sellerproduct.FieldNextStock:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextStock(v)
		return nil
	case sellerproduct.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sellerproduct.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sellerproduct.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SellerProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SellerProductMutation) AddedFields() []string {
	var fields []string
	if m.addselling_price != nil {
		fields = append(fields, sellerproduct.FieldSellingPrice)
	}
	if m.addproduct_price != nil {
		fields = append(fields, sellerproduct.FieldProductPrice)
	}
	if m.addquantity != nil {
		fields = append(fields, sellerproduct.FieldQuantity)
	}
	if m.addoffer_price != nil {
		fields = append(fields, sellerproduct.FieldOfferPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SellerProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sellerproduct.FieldSellingPrice:
		return m.AddedSellingPrice()
	case sellerproduct.FieldProductPrice:
		return m.AddedProductPrice()
	case sellerproduct.FieldQuantity:
		return m.AddedQuantity()
	case sellerproduct.FieldOfferPrice:
		return m.AddedOfferPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sellerproduct.FieldSellingPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSellingPrice(v)
		return nil
	case sellerproduct.FieldProductPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductPrice(v)
		return nil
	case sellerproduct.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case sellerproduct.FieldOfferPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOfferPrice(v)
		return nil
	}
	return fmt.Errorf("unknown SellerProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SellerProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sellerproduct.FieldDescription) {
		fields = append(fields, sellerproduct.FieldDescription)
	}
	if m.FieldCleared(sellerproduct.FieldOfferPriceStart) {
		fields = append(fields, sellerproduct.FieldOfferPriceStart)
	}
	if m.FieldCleared(sellerproduct.FieldOfferPriceEnd) {
		fields = append(fields, sellerproduct.FieldOfferPriceEnd)
	}
	if m.FieldCleared(sellerproduct.FieldNextStock) {
		fields = append(fields, sellerproduct.FieldNextStock)
	}
	if m.FieldCleared(sellerproduct.FieldDeletedAt) {
		fields = append(fields, sellerproduct.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SellerProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SellerProductMutation) ClearField(name string) error {
	switch name {
	case sellerproduct.FieldDescription:
		m.ClearDescription()
		return nil
	case sellerproduct.FieldOfferPriceStart:
		m.ClearOfferPriceStart()
		return nil
	case sellerproduct.FieldOfferPriceEnd:
		m.ClearOfferPriceEnd()
		return nil
	case sellerproduct.FieldNextStock:
		m.ClearNextStock()
		return nil
	case sellerproduct.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SellerProductMutation) ResetField(name string) error {
	switch name {
	case sellerproduct.FieldName:
		m.ResetName()
		return nil
	case sellerproduct.FieldSlug:
		m.ResetSlug()
		return nil
	case sellerproduct.FieldSellingPrice:
		m.ResetSellingPrice()
		return nil
	case sellerproduct.FieldProductPrice:
		m.ResetProductPrice()
		return nil
	case sellerproduct.FieldQuantity:
		m.ResetQuantity()
		return nil
	case sellerproduct.FieldActive:
		m.ResetActive()
		return nil
	case sellerproduct.FieldDescription:
		m.ResetDescription()
		return nil
	case sellerproduct.FieldOfferPrice:
		m.ResetOfferPrice()
		return nil
	case sellerproduct.FieldOfferPriceStart:
		m.ResetOfferPriceStart()
		return nil
	case sellerproduct.FieldOfferPriceEnd:
		m.ResetOfferPriceEnd()
		return nil
	case sellerproduct.FieldNextStock:
		m.ResetNextStock()
		return nil
	case sellerproduct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sellerproduct.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sellerproduct.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SellerProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.brand != nil {
		edges = append(edges, sellerproduct.EdgeBrand)
	}
	if m.user != nil {
		edges = append(edges, sellerproduct.EdgeUser)
	}
	if m.seller_product_images != nil {
		edges = append(edges, sellerproduct.EdgeSellerProductImages)
	}
	if m.categories != nil {
		edges = append(edges, sellerproduct.EdgeCategories)
	}
	if m.shop != nil {
		edges = append(edges, sellerproduct.EdgeShop)
	}
	if m.cart_products != nil {
		edges = append(edges, sellerproduct.EdgeCartProducts)
	}
	if m.checkout_products != nil {
		edges = append(edges, sellerproduct.EdgeCheckoutProducts)
	}
	if m.seller_product_variations != nil {
		edges = append(edges, sellerproduct.EdgeSellerProductVariations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SellerProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sellerproduct.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	case sellerproduct.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case sellerproduct.EdgeSellerProductImages:
		ids := make([]ent.Value, 0, len(m.seller_product_images))
		for id := range m.seller_product_images {
			ids = append(ids, id)
		}
		return ids
	case sellerproduct.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case sellerproduct.EdgeShop:
		if id := m.shop; id != nil {
			return []ent.Value{*id}
		}
	case sellerproduct.EdgeCartProducts:
		ids := make([]ent.Value, 0, len(m.cart_products))
		for id := range m.cart_products {
			ids = append(ids, id)
		}
		return ids
	case sellerproduct.EdgeCheckoutProducts:
		ids := make([]ent.Value, 0, len(m.checkout_products))
		for id := range m.checkout_products {
			ids = append(ids, id)
		}
		return ids
	case sellerproduct.EdgeSellerProductVariations:
		ids := make([]ent.Value, 0, len(m.seller_product_variations))
		for id := range m.seller_product_variations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SellerProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedseller_product_images != nil {
		edges = append(edges, sellerproduct.EdgeSellerProductImages)
	}
	if m.removedcategories != nil {
		edges = append(edges, sellerproduct.EdgeCategories)
	}
	if m.removedcart_products != nil {
		edges = append(edges, sellerproduct.EdgeCartProducts)
	}
	if m.removedcheckout_products != nil {
		edges = append(edges, sellerproduct.EdgeCheckoutProducts)
	}
	if m.removedseller_product_variations != nil {
		edges = append(edges, sellerproduct.EdgeSellerProductVariations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SellerProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sellerproduct.EdgeSellerProductImages:
		ids := make([]ent.Value, 0, len(m.removedseller_product_images))
		for id := range m.removedseller_product_images {
			ids = append(ids, id)
		}
		return ids
	case sellerproduct.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case sellerproduct.EdgeCartProducts:
		ids := make([]ent.Value, 0, len(m.removedcart_products))
		for id := range m.removedcart_products {
			ids = append(ids, id)
		}
		return ids
	case sellerproduct.EdgeCheckoutProducts:
		ids := make([]ent.Value, 0, len(m.removedcheckout_products))
		for id := range m.removedcheckout_products {
			ids = append(ids, id)
		}
		return ids
	case sellerproduct.EdgeSellerProductVariations:
		ids := make([]ent.Value, 0, len(m.removedseller_product_variations))
		for id := range m.removedseller_product_variations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SellerProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedbrand {
		edges = append(edges, sellerproduct.EdgeBrand)
	}
	if m.cleareduser {
		edges = append(edges, sellerproduct.EdgeUser)
	}
	if m.clearedseller_product_images {
		edges = append(edges, sellerproduct.EdgeSellerProductImages)
	}
	if m.clearedcategories {
		edges = append(edges, sellerproduct.EdgeCategories)
	}
	if m.clearedshop {
		edges = append(edges, sellerproduct.EdgeShop)
	}
	if m.clearedcart_products {
		edges = append(edges, sellerproduct.EdgeCartProducts)
	}
	if m.clearedcheckout_products {
		edges = append(edges, sellerproduct.EdgeCheckoutProducts)
	}
	if m.clearedseller_product_variations {
		edges = append(edges, sellerproduct.EdgeSellerProductVariations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SellerProductMutation) EdgeCleared(name string) bool {
	switch name {
	case sellerproduct.EdgeBrand:
		return m.clearedbrand
	case sellerproduct.EdgeUser:
		return m.cleareduser
	case sellerproduct.EdgeSellerProductImages:
		return m.clearedseller_product_images
	case sellerproduct.EdgeCategories:
		return m.clearedcategories
	case sellerproduct.EdgeShop:
		return m.clearedshop
	case sellerproduct.EdgeCartProducts:
		return m.clearedcart_products
	case sellerproduct.EdgeCheckoutProducts:
		return m.clearedcheckout_products
	case sellerproduct.EdgeSellerProductVariations:
		return m.clearedseller_product_variations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SellerProductMutation) ClearEdge(name string) error {
	switch name {
	case sellerproduct.EdgeBrand:
		m.ClearBrand()
		return nil
	case sellerproduct.EdgeUser:
		m.ClearUser()
		return nil
	case sellerproduct.EdgeShop:
		m.ClearShop()
		return nil
	}
	return fmt.Errorf("unknown SellerProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SellerProductMutation) ResetEdge(name string) error {
	switch name {
	case sellerproduct.EdgeBrand:
		m.ResetBrand()
		return nil
	case sellerproduct.EdgeUser:
		m.ResetUser()
		return nil
	case sellerproduct.EdgeSellerProductImages:
		m.ResetSellerProductImages()
		return nil
	case sellerproduct.EdgeCategories:
		m.ResetCategories()
		return nil
	case sellerproduct.EdgeShop:
		m.ResetShop()
		return nil
	case sellerproduct.EdgeCartProducts:
		m.ResetCartProducts()
		return nil
	case sellerproduct.EdgeCheckoutProducts:
		m.ResetCheckoutProducts()
		return nil
	case sellerproduct.EdgeSellerProductVariations:
		m.ResetSellerProductVariations()
		return nil
	}
	return fmt.Errorf("unknown SellerProduct edge %s", name)
}

// SellerProductCategoryMutation represents an operation that mutates the SellerProductCategory nodes in the graph.
type SellerProductCategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SellerProductCategory, error)
	predicates    []predicate.SellerProductCategory
}

var _ ent.Mutation = (*SellerProductCategoryMutation)(nil)

// sellerproductcategoryOption allows management of the mutation configuration using functional options.
type sellerproductcategoryOption func(*SellerProductCategoryMutation)

// newSellerProductCategoryMutation creates new mutation for the SellerProductCategory entity.
func newSellerProductCategoryMutation(c config, op Op, opts ...sellerproductcategoryOption) *SellerProductCategoryMutation {
	m := &SellerProductCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeSellerProductCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSellerProductCategoryID sets the ID field of the mutation.
func withSellerProductCategoryID(id int) sellerproductcategoryOption {
	return func(m *SellerProductCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *SellerProductCategory
		)
		m.oldValue = func(ctx context.Context) (*SellerProductCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SellerProductCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSellerProductCategory sets the old SellerProductCategory of the mutation.
func withSellerProductCategory(node *SellerProductCategory) sellerproductcategoryOption {
	return func(m *SellerProductCategoryMutation) {
		m.oldValue = func(context.Context) (*SellerProductCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SellerProductCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SellerProductCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SellerProductCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SellerProductCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SellerProductCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SellerProductCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SellerProductCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SellerProductCategory entity.
// If the SellerProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SellerProductCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SellerProductCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SellerProductCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SellerProductCategory entity.
// If the SellerProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SellerProductCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SellerProductCategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SellerProductCategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SellerProductCategory entity.
// If the SellerProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductCategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SellerProductCategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sellerproductcategory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SellerProductCategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sellerproductcategory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SellerProductCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sellerproductcategory.FieldDeletedAt)
}

// Where appends a list predicates to the SellerProductCategoryMutation builder.
func (m *SellerProductCategoryMutation) Where(ps ...predicate.SellerProductCategory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SellerProductCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SellerProductCategory).
func (m *SellerProductCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SellerProductCategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, sellerproductcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sellerproductcategory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sellerproductcategory.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SellerProductCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sellerproductcategory.FieldCreatedAt:
		return m.CreatedAt()
	case sellerproductcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case sellerproductcategory.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SellerProductCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sellerproductcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sellerproductcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sellerproductcategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SellerProductCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerProductCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sellerproductcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sellerproductcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sellerproductcategory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SellerProductCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SellerProductCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SellerProductCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerProductCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SellerProductCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SellerProductCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sellerproductcategory.FieldDeletedAt) {
		fields = append(fields, sellerproductcategory.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SellerProductCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SellerProductCategoryMutation) ClearField(name string) error {
	switch name {
	case sellerproductcategory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerProductCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SellerProductCategoryMutation) ResetField(name string) error {
	switch name {
	case sellerproductcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sellerproductcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sellerproductcategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerProductCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SellerProductCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SellerProductCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SellerProductCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SellerProductCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SellerProductCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SellerProductCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SellerProductCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SellerProductCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SellerProductCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SellerProductCategory edge %s", name)
}

// SellerProductImageMutation represents an operation that mutates the SellerProductImage nodes in the graph.
type SellerProductImageMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	display               *bool
	image                 *string
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	clearedFields         map[string]struct{}
	seller_product        *int
	clearedseller_product bool
	done                  bool
	oldValue              func(context.Context) (*SellerProductImage, error)
	predicates            []predicate.SellerProductImage
}

var _ ent.Mutation = (*SellerProductImageMutation)(nil)

// sellerproductimageOption allows management of the mutation configuration using functional options.
type sellerproductimageOption func(*SellerProductImageMutation)

// newSellerProductImageMutation creates new mutation for the SellerProductImage entity.
func newSellerProductImageMutation(c config, op Op, opts ...sellerproductimageOption) *SellerProductImageMutation {
	m := &SellerProductImageMutation{
		config:        c,
		op:            op,
		typ:           TypeSellerProductImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSellerProductImageID sets the ID field of the mutation.
func withSellerProductImageID(id int) sellerproductimageOption {
	return func(m *SellerProductImageMutation) {
		var (
			err   error
			once  sync.Once
			value *SellerProductImage
		)
		m.oldValue = func(ctx context.Context) (*SellerProductImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SellerProductImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSellerProductImage sets the old SellerProductImage of the mutation.
func withSellerProductImage(node *SellerProductImage) sellerproductimageOption {
	return func(m *SellerProductImageMutation) {
		m.oldValue = func(context.Context) (*SellerProductImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SellerProductImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SellerProductImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SellerProductImageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SellerProductImageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SellerProductImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDisplay sets the "display" field.
func (m *SellerProductImageMutation) SetDisplay(b bool) {
	m.display = &b
}

// Display returns the value of the "display" field in the mutation.
func (m *SellerProductImageMutation) Display() (r bool, exists bool) {
	v := m.display
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplay returns the old "display" field's value of the SellerProductImage entity.
// If the SellerProductImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductImageMutation) OldDisplay(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplay: %w", err)
	}
	return oldValue.Display, nil
}

// ResetDisplay resets all changes to the "display" field.
func (m *SellerProductImageMutation) ResetDisplay() {
	m.display = nil
}

// SetImage sets the "image" field.
func (m *SellerProductImageMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *SellerProductImageMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the SellerProductImage entity.
// If the SellerProductImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductImageMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *SellerProductImageMutation) ResetImage() {
	m.image = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SellerProductImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SellerProductImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SellerProductImage entity.
// If the SellerProductImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SellerProductImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SellerProductImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SellerProductImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SellerProductImage entity.
// If the SellerProductImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SellerProductImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SellerProductImageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SellerProductImageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SellerProductImage entity.
// If the SellerProductImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductImageMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SellerProductImageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sellerproductimage.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SellerProductImageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sellerproductimage.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SellerProductImageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sellerproductimage.FieldDeletedAt)
}

// SetSellerProductID sets the "seller_product" edge to the SellerProduct entity by id.
func (m *SellerProductImageMutation) SetSellerProductID(id int) {
	m.seller_product = &id
}

// ClearSellerProduct clears the "seller_product" edge to the SellerProduct entity.
func (m *SellerProductImageMutation) ClearSellerProduct() {
	m.clearedseller_product = true
}

// SellerProductCleared reports if the "seller_product" edge to the SellerProduct entity was cleared.
func (m *SellerProductImageMutation) SellerProductCleared() bool {
	return m.clearedseller_product
}

// SellerProductID returns the "seller_product" edge ID in the mutation.
func (m *SellerProductImageMutation) SellerProductID() (id int, exists bool) {
	if m.seller_product != nil {
		return *m.seller_product, true
	}
	return
}

// SellerProductIDs returns the "seller_product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SellerProductID instead. It exists only for internal usage by the builders.
func (m *SellerProductImageMutation) SellerProductIDs() (ids []int) {
	if id := m.seller_product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSellerProduct resets all changes to the "seller_product" edge.
func (m *SellerProductImageMutation) ResetSellerProduct() {
	m.seller_product = nil
	m.clearedseller_product = false
}

// Where appends a list predicates to the SellerProductImageMutation builder.
func (m *SellerProductImageMutation) Where(ps ...predicate.SellerProductImage) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SellerProductImageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SellerProductImage).
func (m *SellerProductImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SellerProductImageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.display != nil {
		fields = append(fields, sellerproductimage.FieldDisplay)
	}
	if m.image != nil {
		fields = append(fields, sellerproductimage.FieldImage)
	}
	if m.created_at != nil {
		fields = append(fields, sellerproductimage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sellerproductimage.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sellerproductimage.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SellerProductImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sellerproductimage.FieldDisplay:
		return m.Display()
	case sellerproductimage.FieldImage:
		return m.Image()
	case sellerproductimage.FieldCreatedAt:
		return m.CreatedAt()
	case sellerproductimage.FieldUpdatedAt:
		return m.UpdatedAt()
	case sellerproductimage.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SellerProductImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sellerproductimage.FieldDisplay:
		return m.OldDisplay(ctx)
	case sellerproductimage.FieldImage:
		return m.OldImage(ctx)
	case sellerproductimage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sellerproductimage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sellerproductimage.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SellerProductImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerProductImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sellerproductimage.FieldDisplay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplay(v)
		return nil
	case sellerproductimage.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case sellerproductimage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sellerproductimage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sellerproductimage.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SellerProductImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SellerProductImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SellerProductImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerProductImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SellerProductImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SellerProductImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sellerproductimage.FieldDeletedAt) {
		fields = append(fields, sellerproductimage.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SellerProductImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SellerProductImageMutation) ClearField(name string) error {
	switch name {
	case sellerproductimage.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerProductImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SellerProductImageMutation) ResetField(name string) error {
	switch name {
	case sellerproductimage.FieldDisplay:
		m.ResetDisplay()
		return nil
	case sellerproductimage.FieldImage:
		m.ResetImage()
		return nil
	case sellerproductimage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sellerproductimage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sellerproductimage.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerProductImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SellerProductImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.seller_product != nil {
		edges = append(edges, sellerproductimage.EdgeSellerProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SellerProductImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sellerproductimage.EdgeSellerProduct:
		if id := m.seller_product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SellerProductImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SellerProductImageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SellerProductImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedseller_product {
		edges = append(edges, sellerproductimage.EdgeSellerProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SellerProductImageMutation) EdgeCleared(name string) bool {
	switch name {
	case sellerproductimage.EdgeSellerProduct:
		return m.clearedseller_product
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SellerProductImageMutation) ClearEdge(name string) error {
	switch name {
	case sellerproductimage.EdgeSellerProduct:
		m.ClearSellerProduct()
		return nil
	}
	return fmt.Errorf("unknown SellerProductImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SellerProductImageMutation) ResetEdge(name string) error {
	switch name {
	case sellerproductimage.EdgeSellerProduct:
		m.ResetSellerProduct()
		return nil
	}
	return fmt.Errorf("unknown SellerProductImage edge %s", name)
}

// SellerProductVariationMutation represents an operation that mutates the SellerProductVariation nodes in the graph.
type SellerProductVariationMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int
	product_price                          *decimal.Decimal
	addproduct_price                       *decimal.Decimal
	selling_price                          *decimal.Decimal
	addselling_price                       *decimal.Decimal
	quantity                               *int
	addquantity                            *int
	image                                  *string
	created_at                             *time.Time
	updated_at                             *time.Time
	deleted_at                             *time.Time
	clearedFields                          map[string]struct{}
	seller_product                         *int
	clearedseller_product                  bool
	seller_product_variation_values        map[int]struct{}
	removedseller_product_variation_values map[int]struct{}
	clearedseller_product_variation_values bool
	cart_products                          map[int]struct{}
	removedcart_products                   map[int]struct{}
	clearedcart_products                   bool
	checkout_products                      map[int]struct{}
	removedcheckout_products               map[int]struct{}
	clearedcheckout_products               bool
	done                                   bool
	oldValue                               func(context.Context) (*SellerProductVariation, error)
	predicates                             []predicate.SellerProductVariation
}

var _ ent.Mutation = (*SellerProductVariationMutation)(nil)

// sellerproductvariationOption allows management of the mutation configuration using functional options.
type sellerproductvariationOption func(*SellerProductVariationMutation)

// newSellerProductVariationMutation creates new mutation for the SellerProductVariation entity.
func newSellerProductVariationMutation(c config, op Op, opts ...sellerproductvariationOption) *SellerProductVariationMutation {
	m := &SellerProductVariationMutation{
		config:        c,
		op:            op,
		typ:           TypeSellerProductVariation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSellerProductVariationID sets the ID field of the mutation.
func withSellerProductVariationID(id int) sellerproductvariationOption {
	return func(m *SellerProductVariationMutation) {
		var (
			err   error
			once  sync.Once
			value *SellerProductVariation
		)
		m.oldValue = func(ctx context.Context) (*SellerProductVariation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SellerProductVariation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSellerProductVariation sets the old SellerProductVariation of the mutation.
func withSellerProductVariation(node *SellerProductVariation) sellerproductvariationOption {
	return func(m *SellerProductVariationMutation) {
		m.oldValue = func(context.Context) (*SellerProductVariation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SellerProductVariationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SellerProductVariationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SellerProductVariationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SellerProductVariationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SellerProductVariation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProductPrice sets the "product_price" field.
func (m *SellerProductVariationMutation) SetProductPrice(d decimal.Decimal) {
	m.product_price = &d
	m.addproduct_price = nil
}

// ProductPrice returns the value of the "product_price" field in the mutation.
func (m *SellerProductVariationMutation) ProductPrice() (r decimal.Decimal, exists bool) {
	v := m.product_price
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPrice returns the old "product_price" field's value of the SellerProductVariation entity.
// If the SellerProductVariation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductVariationMutation) OldProductPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPrice: %w", err)
	}
	return oldValue.ProductPrice, nil
}

// AddProductPrice adds d to the "product_price" field.
func (m *SellerProductVariationMutation) AddProductPrice(d decimal.Decimal) {
	if m.addproduct_price != nil {
		*m.addproduct_price = m.addproduct_price.Add(d)
	} else {
		m.addproduct_price = &d
	}
}

// AddedProductPrice returns the value that was added to the "product_price" field in this mutation.
func (m *SellerProductVariationMutation) AddedProductPrice() (r decimal.Decimal, exists bool) {
	v := m.addproduct_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductPrice resets all changes to the "product_price" field.
func (m *SellerProductVariationMutation) ResetProductPrice() {
	m.product_price = nil
	m.addproduct_price = nil
}

// SetSellingPrice sets the "selling_price" field.
func (m *SellerProductVariationMutation) SetSellingPrice(d decimal.Decimal) {
	m.selling_price = &d
	m.addselling_price = nil
}

// SellingPrice returns the value of the "selling_price" field in the mutation.
func (m *SellerProductVariationMutation) SellingPrice() (r decimal.Decimal, exists bool) {
	v := m.selling_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSellingPrice returns the old "selling_price" field's value of the SellerProductVariation entity.
// If the SellerProductVariation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductVariationMutation) OldSellingPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellingPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellingPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellingPrice: %w", err)
	}
	return oldValue.SellingPrice, nil
}

// AddSellingPrice adds d to the "selling_price" field.
func (m *SellerProductVariationMutation) AddSellingPrice(d decimal.Decimal) {
	if m.addselling_price != nil {
		*m.addselling_price = m.addselling_price.Add(d)
	} else {
		m.addselling_price = &d
	}
}

// AddedSellingPrice returns the value that was added to the "selling_price" field in this mutation.
func (m *SellerProductVariationMutation) AddedSellingPrice() (r decimal.Decimal, exists bool) {
	v := m.addselling_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetSellingPrice resets all changes to the "selling_price" field.
func (m *SellerProductVariationMutation) ResetSellingPrice() {
	m.selling_price = nil
	m.addselling_price = nil
}

// SetQuantity sets the "quantity" field.
func (m *SellerProductVariationMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *SellerProductVariationMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the SellerProductVariation entity.
// If the SellerProductVariation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductVariationMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *SellerProductVariationMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *SellerProductVariationMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *SellerProductVariationMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetImage sets the "image" field.
func (m *SellerProductVariationMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *SellerProductVariationMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the SellerProductVariation entity.
// If the SellerProductVariation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductVariationMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *SellerProductVariationMutation) ResetImage() {
	m.image = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SellerProductVariationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SellerProductVariationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SellerProductVariation entity.
// If the SellerProductVariation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductVariationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SellerProductVariationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SellerProductVariationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SellerProductVariationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SellerProductVariation entity.
// If the SellerProductVariation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductVariationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SellerProductVariationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SellerProductVariationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SellerProductVariationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SellerProductVariation entity.
// If the SellerProductVariation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductVariationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SellerProductVariationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sellerproductvariation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SellerProductVariationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sellerproductvariation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SellerProductVariationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sellerproductvariation.FieldDeletedAt)
}

// SetSellerProductID sets the "seller_product" edge to the SellerProduct entity by id.
func (m *SellerProductVariationMutation) SetSellerProductID(id int) {
	m.seller_product = &id
}

// ClearSellerProduct clears the "seller_product" edge to the SellerProduct entity.
func (m *SellerProductVariationMutation) ClearSellerProduct() {
	m.clearedseller_product = true
}

// SellerProductCleared reports if the "seller_product" edge to the SellerProduct entity was cleared.
func (m *SellerProductVariationMutation) SellerProductCleared() bool {
	return m.clearedseller_product
}

// SellerProductID returns the "seller_product" edge ID in the mutation.
func (m *SellerProductVariationMutation) SellerProductID() (id int, exists bool) {
	if m.seller_product != nil {
		return *m.seller_product, true
	}
	return
}

// SellerProductIDs returns the "seller_product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SellerProductID instead. It exists only for internal usage by the builders.
func (m *SellerProductVariationMutation) SellerProductIDs() (ids []int) {
	if id := m.seller_product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSellerProduct resets all changes to the "seller_product" edge.
func (m *SellerProductVariationMutation) ResetSellerProduct() {
	m.seller_product = nil
	m.clearedseller_product = false
}

// AddSellerProductVariationValueIDs adds the "seller_product_variation_values" edge to the SellerProductVariationValues entity by ids.
func (m *SellerProductVariationMutation) AddSellerProductVariationValueIDs(ids ...int) {
	if m.seller_product_variation_values == nil {
		m.seller_product_variation_values = make(map[int]struct{})
	}
	for i := range ids {
		m.seller_product_variation_values[ids[i]] = struct{}{}
	}
}

// ClearSellerProductVariationValues clears the "seller_product_variation_values" edge to the SellerProductVariationValues entity.
func (m *SellerProductVariationMutation) ClearSellerProductVariationValues() {
	m.clearedseller_product_variation_values = true
}

// SellerProductVariationValuesCleared reports if the "seller_product_variation_values" edge to the SellerProductVariationValues entity was cleared.
func (m *SellerProductVariationMutation) SellerProductVariationValuesCleared() bool {
	return m.clearedseller_product_variation_values
}

// RemoveSellerProductVariationValueIDs removes the "seller_product_variation_values" edge to the SellerProductVariationValues entity by IDs.
func (m *SellerProductVariationMutation) RemoveSellerProductVariationValueIDs(ids ...int) {
	if m.removedseller_product_variation_values == nil {
		m.removedseller_product_variation_values = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seller_product_variation_values, ids[i])
		m.removedseller_product_variation_values[ids[i]] = struct{}{}
	}
}

// RemovedSellerProductVariationValues returns the removed IDs of the "seller_product_variation_values" edge to the SellerProductVariationValues entity.
func (m *SellerProductVariationMutation) RemovedSellerProductVariationValuesIDs() (ids []int) {
	for id := range m.removedseller_product_variation_values {
		ids = append(ids, id)
	}
	return
}

// SellerProductVariationValuesIDs returns the "seller_product_variation_values" edge IDs in the mutation.
func (m *SellerProductVariationMutation) SellerProductVariationValuesIDs() (ids []int) {
	for id := range m.seller_product_variation_values {
		ids = append(ids, id)
	}
	return
}

// ResetSellerProductVariationValues resets all changes to the "seller_product_variation_values" edge.
func (m *SellerProductVariationMutation) ResetSellerProductVariationValues() {
	m.seller_product_variation_values = nil
	m.clearedseller_product_variation_values = false
	m.removedseller_product_variation_values = nil
}

// AddCartProductIDs adds the "cart_products" edge to the CartProduct entity by ids.
func (m *SellerProductVariationMutation) AddCartProductIDs(ids ...int) {
	if m.cart_products == nil {
		m.cart_products = make(map[int]struct{})
	}
	for i := range ids {
		m.cart_products[ids[i]] = struct{}{}
	}
}

// ClearCartProducts clears the "cart_products" edge to the CartProduct entity.
func (m *SellerProductVariationMutation) ClearCartProducts() {
	m.clearedcart_products = true
}

// CartProductsCleared reports if the "cart_products" edge to the CartProduct entity was cleared.
func (m *SellerProductVariationMutation) CartProductsCleared() bool {
	return m.clearedcart_products
}

// RemoveCartProductIDs removes the "cart_products" edge to the CartProduct entity by IDs.
func (m *SellerProductVariationMutation) RemoveCartProductIDs(ids ...int) {
	if m.removedcart_products == nil {
		m.removedcart_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cart_products, ids[i])
		m.removedcart_products[ids[i]] = struct{}{}
	}
}

// RemovedCartProducts returns the removed IDs of the "cart_products" edge to the CartProduct entity.
func (m *SellerProductVariationMutation) RemovedCartProductsIDs() (ids []int) {
	for id := range m.removedcart_products {
		ids = append(ids, id)
	}
	return
}

// CartProductsIDs returns the "cart_products" edge IDs in the mutation.
func (m *SellerProductVariationMutation) CartProductsIDs() (ids []int) {
	for id := range m.cart_products {
		ids = append(ids, id)
	}
	return
}

// ResetCartProducts resets all changes to the "cart_products" edge.
func (m *SellerProductVariationMutation) ResetCartProducts() {
	m.cart_products = nil
	m.clearedcart_products = false
	m.removedcart_products = nil
}

// AddCheckoutProductIDs adds the "checkout_products" edge to the CheckoutProduct entity by ids.
func (m *SellerProductVariationMutation) AddCheckoutProductIDs(ids ...int) {
	if m.checkout_products == nil {
		m.checkout_products = make(map[int]struct{})
	}
	for i := range ids {
		m.checkout_products[ids[i]] = struct{}{}
	}
}

// ClearCheckoutProducts clears the "checkout_products" edge to the CheckoutProduct entity.
func (m *SellerProductVariationMutation) ClearCheckoutProducts() {
	m.clearedcheckout_products = true
}

// CheckoutProductsCleared reports if the "checkout_products" edge to the CheckoutProduct entity was cleared.
func (m *SellerProductVariationMutation) CheckoutProductsCleared() bool {
	return m.clearedcheckout_products
}

// RemoveCheckoutProductIDs removes the "checkout_products" edge to the CheckoutProduct entity by IDs.
func (m *SellerProductVariationMutation) RemoveCheckoutProductIDs(ids ...int) {
	if m.removedcheckout_products == nil {
		m.removedcheckout_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.checkout_products, ids[i])
		m.removedcheckout_products[ids[i]] = struct{}{}
	}
}

// RemovedCheckoutProducts returns the removed IDs of the "checkout_products" edge to the CheckoutProduct entity.
func (m *SellerProductVariationMutation) RemovedCheckoutProductsIDs() (ids []int) {
	for id := range m.removedcheckout_products {
		ids = append(ids, id)
	}
	return
}

// CheckoutProductsIDs returns the "checkout_products" edge IDs in the mutation.
func (m *SellerProductVariationMutation) CheckoutProductsIDs() (ids []int) {
	for id := range m.checkout_products {
		ids = append(ids, id)
	}
	return
}

// ResetCheckoutProducts resets all changes to the "checkout_products" edge.
func (m *SellerProductVariationMutation) ResetCheckoutProducts() {
	m.checkout_products = nil
	m.clearedcheckout_products = false
	m.removedcheckout_products = nil
}

// Where appends a list predicates to the SellerProductVariationMutation builder.
func (m *SellerProductVariationMutation) Where(ps ...predicate.SellerProductVariation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SellerProductVariationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SellerProductVariation).
func (m *SellerProductVariationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SellerProductVariationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.product_price != nil {
		fields = append(fields, sellerproductvariation.FieldProductPrice)
	}
	if m.selling_price != nil {
		fields = append(fields, sellerproductvariation.FieldSellingPrice)
	}
	if m.quantity != nil {
		fields = append(fields, sellerproductvariation.FieldQuantity)
	}
	if m.image != nil {
		fields = append(fields, sellerproductvariation.FieldImage)
	}
	if m.created_at != nil {
		fields = append(fields, sellerproductvariation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sellerproductvariation.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sellerproductvariation.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SellerProductVariationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sellerproductvariation.FieldProductPrice:
		return m.ProductPrice()
	case sellerproductvariation.FieldSellingPrice:
		return m.SellingPrice()
	case sellerproductvariation.FieldQuantity:
		return m.Quantity()
	case sellerproductvariation.FieldImage:
		return m.Image()
	case sellerproductvariation.FieldCreatedAt:
		return m.CreatedAt()
	case sellerproductvariation.FieldUpdatedAt:
		return m.UpdatedAt()
	case sellerproductvariation.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SellerProductVariationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sellerproductvariation.FieldProductPrice:
		return m.OldProductPrice(ctx)
	case sellerproductvariation.FieldSellingPrice:
		return m.OldSellingPrice(ctx)
	case sellerproductvariation.FieldQuantity:
		return m.OldQuantity(ctx)
	case sellerproductvariation.FieldImage:
		return m.OldImage(ctx)
	case sellerproductvariation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sellerproductvariation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sellerproductvariation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SellerProductVariation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerProductVariationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sellerproductvariation.FieldProductPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPrice(v)
		return nil
	case sellerproductvariation.FieldSellingPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellingPrice(v)
		return nil
	case sellerproductvariation.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case sellerproductvariation.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case sellerproductvariation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sellerproductvariation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sellerproductvariation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SellerProductVariation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SellerProductVariationMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_price != nil {
		fields = append(fields, sellerproductvariation.FieldProductPrice)
	}
	if m.addselling_price != nil {
		fields = append(fields, sellerproductvariation.FieldSellingPrice)
	}
	if m.addquantity != nil {
		fields = append(fields, sellerproductvariation.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SellerProductVariationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sellerproductvariation.FieldProductPrice:
		return m.AddedProductPrice()
	case sellerproductvariation.FieldSellingPrice:
		return m.AddedSellingPrice()
	case sellerproductvariation.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerProductVariationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sellerproductvariation.FieldProductPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductPrice(v)
		return nil
	case sellerproductvariation.FieldSellingPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSellingPrice(v)
		return nil
	case sellerproductvariation.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown SellerProductVariation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SellerProductVariationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sellerproductvariation.FieldDeletedAt) {
		fields = append(fields, sellerproductvariation.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SellerProductVariationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SellerProductVariationMutation) ClearField(name string) error {
	switch name {
	case sellerproductvariation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerProductVariation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SellerProductVariationMutation) ResetField(name string) error {
	switch name {
	case sellerproductvariation.FieldProductPrice:
		m.ResetProductPrice()
		return nil
	case sellerproductvariation.FieldSellingPrice:
		m.ResetSellingPrice()
		return nil
	case sellerproductvariation.FieldQuantity:
		m.ResetQuantity()
		return nil
	case sellerproductvariation.FieldImage:
		m.ResetImage()
		return nil
	case sellerproductvariation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sellerproductvariation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sellerproductvariation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerProductVariation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SellerProductVariationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.seller_product != nil {
		edges = append(edges, sellerproductvariation.EdgeSellerProduct)
	}
	if m.seller_product_variation_values != nil {
		edges = append(edges, sellerproductvariation.EdgeSellerProductVariationValues)
	}
	if m.cart_products != nil {
		edges = append(edges, sellerproductvariation.EdgeCartProducts)
	}
	if m.checkout_products != nil {
		edges = append(edges, sellerproductvariation.EdgeCheckoutProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SellerProductVariationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sellerproductvariation.EdgeSellerProduct:
		if id := m.seller_product; id != nil {
			return []ent.Value{*id}
		}
	case sellerproductvariation.EdgeSellerProductVariationValues:
		ids := make([]ent.Value, 0, len(m.seller_product_variation_values))
		for id := range m.seller_product_variation_values {
			ids = append(ids, id)
		}
		return ids
	case sellerproductvariation.EdgeCartProducts:
		ids := make([]ent.Value, 0, len(m.cart_products))
		for id := range m.cart_products {
			ids = append(ids, id)
		}
		return ids
	case sellerproductvariation.EdgeCheckoutProducts:
		ids := make([]ent.Value, 0, len(m.checkout_products))
		for id := range m.checkout_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SellerProductVariationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedseller_product_variation_values != nil {
		edges = append(edges, sellerproductvariation.EdgeSellerProductVariationValues)
	}
	if m.removedcart_products != nil {
		edges = append(edges, sellerproductvariation.EdgeCartProducts)
	}
	if m.removedcheckout_products != nil {
		edges = append(edges, sellerproductvariation.EdgeCheckoutProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SellerProductVariationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sellerproductvariation.EdgeSellerProductVariationValues:
		ids := make([]ent.Value, 0, len(m.removedseller_product_variation_values))
		for id := range m.removedseller_product_variation_values {
			ids = append(ids, id)
		}
		return ids
	case sellerproductvariation.EdgeCartProducts:
		ids := make([]ent.Value, 0, len(m.removedcart_products))
		for id := range m.removedcart_products {
			ids = append(ids, id)
		}
		return ids
	case sellerproductvariation.EdgeCheckoutProducts:
		ids := make([]ent.Value, 0, len(m.removedcheckout_products))
		for id := range m.removedcheckout_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SellerProductVariationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedseller_product {
		edges = append(edges, sellerproductvariation.EdgeSellerProduct)
	}
	if m.clearedseller_product_variation_values {
		edges = append(edges, sellerproductvariation.EdgeSellerProductVariationValues)
	}
	if m.clearedcart_products {
		edges = append(edges, sellerproductvariation.EdgeCartProducts)
	}
	if m.clearedcheckout_products {
		edges = append(edges, sellerproductvariation.EdgeCheckoutProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SellerProductVariationMutation) EdgeCleared(name string) bool {
	switch name {
	case sellerproductvariation.EdgeSellerProduct:
		return m.clearedseller_product
	case sellerproductvariation.EdgeSellerProductVariationValues:
		return m.clearedseller_product_variation_values
	case sellerproductvariation.EdgeCartProducts:
		return m.clearedcart_products
	case sellerproductvariation.EdgeCheckoutProducts:
		return m.clearedcheckout_products
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SellerProductVariationMutation) ClearEdge(name string) error {
	switch name {
	case sellerproductvariation.EdgeSellerProduct:
		m.ClearSellerProduct()
		return nil
	}
	return fmt.Errorf("unknown SellerProductVariation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SellerProductVariationMutation) ResetEdge(name string) error {
	switch name {
	case sellerproductvariation.EdgeSellerProduct:
		m.ResetSellerProduct()
		return nil
	case sellerproductvariation.EdgeSellerProductVariationValues:
		m.ResetSellerProductVariationValues()
		return nil
	case sellerproductvariation.EdgeCartProducts:
		m.ResetCartProducts()
		return nil
	case sellerproductvariation.EdgeCheckoutProducts:
		m.ResetCheckoutProducts()
		return nil
	}
	return fmt.Errorf("unknown SellerProductVariation edge %s", name)
}

// SellerProductVariationValuesMutation represents an operation that mutates the SellerProductVariationValues nodes in the graph.
type SellerProductVariationValuesMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	name                            *string
	description                     *string
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	clearedFields                   map[string]struct{}
	attribute                       *int
	clearedattribute                bool
	seller_product_variation        *int
	clearedseller_product_variation bool
	done                            bool
	oldValue                        func(context.Context) (*SellerProductVariationValues, error)
	predicates                      []predicate.SellerProductVariationValues
}

var _ ent.Mutation = (*SellerProductVariationValuesMutation)(nil)

// sellerproductvariationvaluesOption allows management of the mutation configuration using functional options.
type sellerproductvariationvaluesOption func(*SellerProductVariationValuesMutation)

// newSellerProductVariationValuesMutation creates new mutation for the SellerProductVariationValues entity.
func newSellerProductVariationValuesMutation(c config, op Op, opts ...sellerproductvariationvaluesOption) *SellerProductVariationValuesMutation {
	m := &SellerProductVariationValuesMutation{
		config:        c,
		op:            op,
		typ:           TypeSellerProductVariationValues,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSellerProductVariationValuesID sets the ID field of the mutation.
func withSellerProductVariationValuesID(id int) sellerproductvariationvaluesOption {
	return func(m *SellerProductVariationValuesMutation) {
		var (
			err   error
			once  sync.Once
			value *SellerProductVariationValues
		)
		m.oldValue = func(ctx context.Context) (*SellerProductVariationValues, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SellerProductVariationValues.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSellerProductVariationValues sets the old SellerProductVariationValues of the mutation.
func withSellerProductVariationValues(node *SellerProductVariationValues) sellerproductvariationvaluesOption {
	return func(m *SellerProductVariationValuesMutation) {
		m.oldValue = func(context.Context) (*SellerProductVariationValues, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SellerProductVariationValuesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SellerProductVariationValuesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SellerProductVariationValuesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SellerProductVariationValuesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SellerProductVariationValues.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SellerProductVariationValuesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SellerProductVariationValuesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SellerProductVariationValues entity.
// If the SellerProductVariationValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductVariationValuesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SellerProductVariationValuesMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SellerProductVariationValuesMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SellerProductVariationValuesMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SellerProductVariationValues entity.
// If the SellerProductVariationValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductVariationValuesMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SellerProductVariationValuesMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SellerProductVariationValuesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SellerProductVariationValuesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SellerProductVariationValues entity.
// If the SellerProductVariationValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductVariationValuesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SellerProductVariationValuesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SellerProductVariationValuesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SellerProductVariationValuesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SellerProductVariationValues entity.
// If the SellerProductVariationValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductVariationValuesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SellerProductVariationValuesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SellerProductVariationValuesMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SellerProductVariationValuesMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SellerProductVariationValues entity.
// If the SellerProductVariationValues object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerProductVariationValuesMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SellerProductVariationValuesMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sellerproductvariationvalues.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SellerProductVariationValuesMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sellerproductvariationvalues.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SellerProductVariationValuesMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sellerproductvariationvalues.FieldDeletedAt)
}

// SetAttributeID sets the "attribute" edge to the Attribute entity by id.
func (m *SellerProductVariationValuesMutation) SetAttributeID(id int) {
	m.attribute = &id
}

// ClearAttribute clears the "attribute" edge to the Attribute entity.
func (m *SellerProductVariationValuesMutation) ClearAttribute() {
	m.clearedattribute = true
}

// AttributeCleared reports if the "attribute" edge to the Attribute entity was cleared.
func (m *SellerProductVariationValuesMutation) AttributeCleared() bool {
	return m.clearedattribute
}

// AttributeID returns the "attribute" edge ID in the mutation.
func (m *SellerProductVariationValuesMutation) AttributeID() (id int, exists bool) {
	if m.attribute != nil {
		return *m.attribute, true
	}
	return
}

// AttributeIDs returns the "attribute" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttributeID instead. It exists only for internal usage by the builders.
func (m *SellerProductVariationValuesMutation) AttributeIDs() (ids []int) {
	if id := m.attribute; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttribute resets all changes to the "attribute" edge.
func (m *SellerProductVariationValuesMutation) ResetAttribute() {
	m.attribute = nil
	m.clearedattribute = false
}

// SetSellerProductVariationID sets the "seller_product_variation" edge to the SellerProductVariation entity by id.
func (m *SellerProductVariationValuesMutation) SetSellerProductVariationID(id int) {
	m.seller_product_variation = &id
}

// ClearSellerProductVariation clears the "seller_product_variation" edge to the SellerProductVariation entity.
func (m *SellerProductVariationValuesMutation) ClearSellerProductVariation() {
	m.clearedseller_product_variation = true
}

// SellerProductVariationCleared reports if the "seller_product_variation" edge to the SellerProductVariation entity was cleared.
func (m *SellerProductVariationValuesMutation) SellerProductVariationCleared() bool {
	return m.clearedseller_product_variation
}

// SellerProductVariationID returns the "seller_product_variation" edge ID in the mutation.
func (m *SellerProductVariationValuesMutation) SellerProductVariationID() (id int, exists bool) {
	if m.seller_product_variation != nil {
		return *m.seller_product_variation, true
	}
	return
}

// SellerProductVariationIDs returns the "seller_product_variation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SellerProductVariationID instead. It exists only for internal usage by the builders.
func (m *SellerProductVariationValuesMutation) SellerProductVariationIDs() (ids []int) {
	if id := m.seller_product_variation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSellerProductVariation resets all changes to the "seller_product_variation" edge.
func (m *SellerProductVariationValuesMutation) ResetSellerProductVariation() {
	m.seller_product_variation = nil
	m.clearedseller_product_variation = false
}

// Where appends a list predicates to the SellerProductVariationValuesMutation builder.
func (m *SellerProductVariationValuesMutation) Where(ps ...predicate.SellerProductVariationValues) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SellerProductVariationValuesMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SellerProductVariationValues).
func (m *SellerProductVariationValuesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SellerProductVariationValuesMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, sellerproductvariationvalues.FieldName)
	}
	if m.description != nil {
		fields = append(fields, sellerproductvariationvalues.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, sellerproductvariationvalues.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sellerproductvariationvalues.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sellerproductvariationvalues.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SellerProductVariationValuesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sellerproductvariationvalues.FieldName:
		return m.Name()
	case sellerproductvariationvalues.FieldDescription:
		return m.Description()
	case sellerproductvariationvalues.FieldCreatedAt:
		return m.CreatedAt()
	case sellerproductvariationvalues.FieldUpdatedAt:
		return m.UpdatedAt()
	case sellerproductvariationvalues.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SellerProductVariationValuesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sellerproductvariationvalues.FieldName:
		return m.OldName(ctx)
	case sellerproductvariationvalues.FieldDescription:
		return m.OldDescription(ctx)
	case sellerproductvariationvalues.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sellerproductvariationvalues.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sellerproductvariationvalues.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SellerProductVariationValues field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerProductVariationValuesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sellerproductvariationvalues.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sellerproductvariationvalues.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case sellerproductvariationvalues.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sellerproductvariationvalues.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sellerproductvariationvalues.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SellerProductVariationValues field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SellerProductVariationValuesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SellerProductVariationValuesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerProductVariationValuesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SellerProductVariationValues numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SellerProductVariationValuesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sellerproductvariationvalues.FieldDeletedAt) {
		fields = append(fields, sellerproductvariationvalues.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SellerProductVariationValuesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SellerProductVariationValuesMutation) ClearField(name string) error {
	switch name {
	case sellerproductvariationvalues.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerProductVariationValues nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SellerProductVariationValuesMutation) ResetField(name string) error {
	switch name {
	case sellerproductvariationvalues.FieldName:
		m.ResetName()
		return nil
	case sellerproductvariationvalues.FieldDescription:
		m.ResetDescription()
		return nil
	case sellerproductvariationvalues.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sellerproductvariationvalues.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sellerproductvariationvalues.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerProductVariationValues field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SellerProductVariationValuesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.attribute != nil {
		edges = append(edges, sellerproductvariationvalues.EdgeAttribute)
	}
	if m.seller_product_variation != nil {
		edges = append(edges, sellerproductvariationvalues.EdgeSellerProductVariation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SellerProductVariationValuesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sellerproductvariationvalues.EdgeAttribute:
		if id := m.attribute; id != nil {
			return []ent.Value{*id}
		}
	case sellerproductvariationvalues.EdgeSellerProductVariation:
		if id := m.seller_product_variation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SellerProductVariationValuesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SellerProductVariationValuesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SellerProductVariationValuesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedattribute {
		edges = append(edges, sellerproductvariationvalues.EdgeAttribute)
	}
	if m.clearedseller_product_variation {
		edges = append(edges, sellerproductvariationvalues.EdgeSellerProductVariation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SellerProductVariationValuesMutation) EdgeCleared(name string) bool {
	switch name {
	case sellerproductvariationvalues.EdgeAttribute:
		return m.clearedattribute
	case sellerproductvariationvalues.EdgeSellerProductVariation:
		return m.clearedseller_product_variation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SellerProductVariationValuesMutation) ClearEdge(name string) error {
	switch name {
	case sellerproductvariationvalues.EdgeAttribute:
		m.ClearAttribute()
		return nil
	case sellerproductvariationvalues.EdgeSellerProductVariation:
		m.ClearSellerProductVariation()
		return nil
	}
	return fmt.Errorf("unknown SellerProductVariationValues unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SellerProductVariationValuesMutation) ResetEdge(name string) error {
	switch name {
	case sellerproductvariationvalues.EdgeAttribute:
		m.ResetAttribute()
		return nil
	case sellerproductvariationvalues.EdgeSellerProductVariation:
		m.ResetSellerProductVariation()
		return nil
	}
	return fmt.Errorf("unknown SellerProductVariationValues edge %s", name)
}

// SellerRequestMutation represents an operation that mutates the SellerRequest nodes in the graph.
type SellerRequestMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	seller_name          *string
	shop_name            *string
	contact_number       *string
	shop_location        *string
	tax_id               *string
	accepted             *bool
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	clearedFields        map[string]struct{}
	shop_category        *int
	clearedshop_category bool
	user                 *int
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*SellerRequest, error)
	predicates           []predicate.SellerRequest
}

var _ ent.Mutation = (*SellerRequestMutation)(nil)

// sellerrequestOption allows management of the mutation configuration using functional options.
type sellerrequestOption func(*SellerRequestMutation)

// newSellerRequestMutation creates new mutation for the SellerRequest entity.
func newSellerRequestMutation(c config, op Op, opts ...sellerrequestOption) *SellerRequestMutation {
	m := &SellerRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeSellerRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSellerRequestID sets the ID field of the mutation.
func withSellerRequestID(id int) sellerrequestOption {
	return func(m *SellerRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *SellerRequest
		)
		m.oldValue = func(ctx context.Context) (*SellerRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SellerRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSellerRequest sets the old SellerRequest of the mutation.
func withSellerRequest(node *SellerRequest) sellerrequestOption {
	return func(m *SellerRequestMutation) {
		m.oldValue = func(context.Context) (*SellerRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SellerRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SellerRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SellerRequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SellerRequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SellerRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSellerName sets the "seller_name" field.
func (m *SellerRequestMutation) SetSellerName(s string) {
	m.seller_name = &s
}

// SellerName returns the value of the "seller_name" field in the mutation.
func (m *SellerRequestMutation) SellerName() (r string, exists bool) {
	v := m.seller_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSellerName returns the old "seller_name" field's value of the SellerRequest entity.
// If the SellerRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerRequestMutation) OldSellerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellerName: %w", err)
	}
	return oldValue.SellerName, nil
}

// ResetSellerName resets all changes to the "seller_name" field.
func (m *SellerRequestMutation) ResetSellerName() {
	m.seller_name = nil
}

// SetShopName sets the "shop_name" field.
func (m *SellerRequestMutation) SetShopName(s string) {
	m.shop_name = &s
}

// ShopName returns the value of the "shop_name" field in the mutation.
func (m *SellerRequestMutation) ShopName() (r string, exists bool) {
	v := m.shop_name
	if v == nil {
		return
	}
	return *v, true
}

// OldShopName returns the old "shop_name" field's value of the SellerRequest entity.
// If the SellerRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerRequestMutation) OldShopName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShopName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShopName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShopName: %w", err)
	}
	return oldValue.ShopName, nil
}

// ResetShopName resets all changes to the "shop_name" field.
func (m *SellerRequestMutation) ResetShopName() {
	m.shop_name = nil
}

// SetContactNumber sets the "contact_number" field.
func (m *SellerRequestMutation) SetContactNumber(s string) {
	m.contact_number = &s
}

// ContactNumber returns the value of the "contact_number" field in the mutation.
func (m *SellerRequestMutation) ContactNumber() (r string, exists bool) {
	v := m.contact_number
	if v == nil {
		return
	}
	return *v, true
}

// OldContactNumber returns the old "contact_number" field's value of the SellerRequest entity.
// If the SellerRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerRequestMutation) OldContactNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactNumber: %w", err)
	}
	return oldValue.ContactNumber, nil
}

// ResetContactNumber resets all changes to the "contact_number" field.
func (m *SellerRequestMutation) ResetContactNumber() {
	m.contact_number = nil
}

// SetShopLocation sets the "shop_location" field.
func (m *SellerRequestMutation) SetShopLocation(s string) {
	m.shop_location = &s
}

// ShopLocation returns the value of the "shop_location" field in the mutation.
func (m *SellerRequestMutation) ShopLocation() (r string, exists bool) {
	v := m.shop_location
	if v == nil {
		return
	}
	return *v, true
}

// OldShopLocation returns the old "shop_location" field's value of the SellerRequest entity.
// If the SellerRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerRequestMutation) OldShopLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShopLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShopLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShopLocation: %w", err)
	}
	return oldValue.ShopLocation, nil
}

// ResetShopLocation resets all changes to the "shop_location" field.
func (m *SellerRequestMutation) ResetShopLocation() {
	m.shop_location = nil
}

// SetTaxID sets the "tax_id" field.
func (m *SellerRequestMutation) SetTaxID(s string) {
	m.tax_id = &s
}

// TaxID returns the value of the "tax_id" field in the mutation.
func (m *SellerRequestMutation) TaxID() (r string, exists bool) {
	v := m.tax_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "tax_id" field's value of the SellerRequest entity.
// If the SellerRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerRequestMutation) OldTaxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ResetTaxID resets all changes to the "tax_id" field.
func (m *SellerRequestMutation) ResetTaxID() {
	m.tax_id = nil
}

// SetAccepted sets the "accepted" field.
func (m *SellerRequestMutation) SetAccepted(b bool) {
	m.accepted = &b
}

// Accepted returns the value of the "accepted" field in the mutation.
func (m *SellerRequestMutation) Accepted() (r bool, exists bool) {
	v := m.accepted
	if v == nil {
		return
	}
	return *v, true
}

// OldAccepted returns the old "accepted" field's value of the SellerRequest entity.
// If the SellerRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerRequestMutation) OldAccepted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccepted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccepted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccepted: %w", err)
	}
	return oldValue.Accepted, nil
}

// ResetAccepted resets all changes to the "accepted" field.
func (m *SellerRequestMutation) ResetAccepted() {
	m.accepted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SellerRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SellerRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SellerRequest entity.
// If the SellerRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SellerRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SellerRequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SellerRequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SellerRequest entity.
// If the SellerRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerRequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SellerRequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SellerRequestMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SellerRequestMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SellerRequest entity.
// If the SellerRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerRequestMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SellerRequestMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sellerrequest.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SellerRequestMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sellerrequest.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SellerRequestMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sellerrequest.FieldDeletedAt)
}

// SetShopCategoryID sets the "shop_category" edge to the ShopCategory entity by id.
func (m *SellerRequestMutation) SetShopCategoryID(id int) {
	m.shop_category = &id
}

// ClearShopCategory clears the "shop_category" edge to the ShopCategory entity.
func (m *SellerRequestMutation) ClearShopCategory() {
	m.clearedshop_category = true
}

// ShopCategoryCleared reports if the "shop_category" edge to the ShopCategory entity was cleared.
func (m *SellerRequestMutation) ShopCategoryCleared() bool {
	return m.clearedshop_category
}

// ShopCategoryID returns the "shop_category" edge ID in the mutation.
func (m *SellerRequestMutation) ShopCategoryID() (id int, exists bool) {
	if m.shop_category != nil {
		return *m.shop_category, true
	}
	return
}

// ShopCategoryIDs returns the "shop_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShopCategoryID instead. It exists only for internal usage by the builders.
func (m *SellerRequestMutation) ShopCategoryIDs() (ids []int) {
	if id := m.shop_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShopCategory resets all changes to the "shop_category" edge.
func (m *SellerRequestMutation) ResetShopCategory() {
	m.shop_category = nil
	m.clearedshop_category = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SellerRequestMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SellerRequestMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SellerRequestMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SellerRequestMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SellerRequestMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SellerRequestMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SellerRequestMutation builder.
func (m *SellerRequestMutation) Where(ps ...predicate.SellerRequest) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SellerRequestMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SellerRequest).
func (m *SellerRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SellerRequestMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.seller_name != nil {
		fields = append(fields, sellerrequest.FieldSellerName)
	}
	if m.shop_name != nil {
		fields = append(fields, sellerrequest.FieldShopName)
	}
	if m.contact_number != nil {
		fields = append(fields, sellerrequest.FieldContactNumber)
	}
	if m.shop_location != nil {
		fields = append(fields, sellerrequest.FieldShopLocation)
	}
	if m.tax_id != nil {
		fields = append(fields, sellerrequest.FieldTaxID)
	}
	if m.accepted != nil {
		fields = append(fields, sellerrequest.FieldAccepted)
	}
	if m.created_at != nil {
		fields = append(fields, sellerrequest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sellerrequest.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sellerrequest.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SellerRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sellerrequest.FieldSellerName:
		return m.SellerName()
	case sellerrequest.FieldShopName:
		return m.ShopName()
	case sellerrequest.FieldContactNumber:
		return m.ContactNumber()
	case sellerrequest.FieldShopLocation:
		return m.ShopLocation()
	case sellerrequest.FieldTaxID:
		return m.TaxID()
	case sellerrequest.FieldAccepted:
		return m.Accepted()
	case sellerrequest.FieldCreatedAt:
		return m.CreatedAt()
	case sellerrequest.FieldUpdatedAt:
		return m.UpdatedAt()
	case sellerrequest.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SellerRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sellerrequest.FieldSellerName:
		return m.OldSellerName(ctx)
	case sellerrequest.FieldShopName:
		return m.OldShopName(ctx)
	case sellerrequest.FieldContactNumber:
		return m.OldContactNumber(ctx)
	case sellerrequest.FieldShopLocation:
		return m.OldShopLocation(ctx)
	case sellerrequest.FieldTaxID:
		return m.OldTaxID(ctx)
	case sellerrequest.FieldAccepted:
		return m.OldAccepted(ctx)
	case sellerrequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sellerrequest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sellerrequest.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SellerRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sellerrequest.FieldSellerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellerName(v)
		return nil
	case sellerrequest.FieldShopName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShopName(v)
		return nil
	case sellerrequest.FieldContactNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactNumber(v)
		return nil
	case sellerrequest.FieldShopLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShopLocation(v)
		return nil
	case sellerrequest.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	case sellerrequest.FieldAccepted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccepted(v)
		return nil
	case sellerrequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sellerrequest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sellerrequest.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SellerRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SellerRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SellerRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SellerRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SellerRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sellerrequest.FieldDeletedAt) {
		fields = append(fields, sellerrequest.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SellerRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SellerRequestMutation) ClearField(name string) error {
	switch name {
	case sellerrequest.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SellerRequestMutation) ResetField(name string) error {
	switch name {
	case sellerrequest.FieldSellerName:
		m.ResetSellerName()
		return nil
	case sellerrequest.FieldShopName:
		m.ResetShopName()
		return nil
	case sellerrequest.FieldContactNumber:
		m.ResetContactNumber()
		return nil
	case sellerrequest.FieldShopLocation:
		m.ResetShopLocation()
		return nil
	case sellerrequest.FieldTaxID:
		m.ResetTaxID()
		return nil
	case sellerrequest.FieldAccepted:
		m.ResetAccepted()
		return nil
	case sellerrequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sellerrequest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sellerrequest.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SellerRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.shop_category != nil {
		edges = append(edges, sellerrequest.EdgeShopCategory)
	}
	if m.user != nil {
		edges = append(edges, sellerrequest.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SellerRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sellerrequest.EdgeShopCategory:
		if id := m.shop_category; id != nil {
			return []ent.Value{*id}
		}
	case sellerrequest.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SellerRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SellerRequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SellerRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedshop_category {
		edges = append(edges, sellerrequest.EdgeShopCategory)
	}
	if m.cleareduser {
		edges = append(edges, sellerrequest.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SellerRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case sellerrequest.EdgeShopCategory:
		return m.clearedshop_category
	case sellerrequest.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SellerRequestMutation) ClearEdge(name string) error {
	switch name {
	case sellerrequest.EdgeShopCategory:
		m.ClearShopCategory()
		return nil
	case sellerrequest.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown SellerRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SellerRequestMutation) ResetEdge(name string) error {
	switch name {
	case sellerrequest.EdgeShopCategory:
		m.ResetShopCategory()
		return nil
	case sellerrequest.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown SellerRequest edge %s", name)
}

// SellerShopMutation represents an operation that mutates the SellerShop nodes in the graph.
type SellerShopMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	slug                     *string
	contact_number           *string
	banner                   *string
	business_location        *string
	tax_id                   *string
	active                   *bool
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	clearedFields            map[string]struct{}
	user                     *int
	cleareduser              bool
	admin                    *int
	clearedadmin             bool
	get_shop_category        *int
	clearedget_shop_category bool
	seller_products          map[int]struct{}
	removedseller_products   map[int]struct{}
	clearedseller_products   bool
	done                     bool
	oldValue                 func(context.Context) (*SellerShop, error)
	predicates               []predicate.SellerShop
}

var _ ent.Mutation = (*SellerShopMutation)(nil)

// sellershopOption allows management of the mutation configuration using functional options.
type sellershopOption func(*SellerShopMutation)

// newSellerShopMutation creates new mutation for the SellerShop entity.
func newSellerShopMutation(c config, op Op, opts ...sellershopOption) *SellerShopMutation {
	m := &SellerShopMutation{
		config:        c,
		op:            op,
		typ:           TypeSellerShop,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSellerShopID sets the ID field of the mutation.
func withSellerShopID(id int) sellershopOption {
	return func(m *SellerShopMutation) {
		var (
			err   error
			once  sync.Once
			value *SellerShop
		)
		m.oldValue = func(ctx context.Context) (*SellerShop, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SellerShop.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSellerShop sets the old SellerShop of the mutation.
func withSellerShop(node *SellerShop) sellershopOption {
	return func(m *SellerShopMutation) {
		m.oldValue = func(context.Context) (*SellerShop, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SellerShopMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SellerShopMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SellerShopMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SellerShopMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SellerShop.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SellerShopMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SellerShopMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SellerShop entity.
// If the SellerShop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerShopMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SellerShopMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *SellerShopMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *SellerShopMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the SellerShop entity.
// If the SellerShop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerShopMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *SellerShopMutation) ResetSlug() {
	m.slug = nil
}

// SetContactNumber sets the "contact_number" field.
func (m *SellerShopMutation) SetContactNumber(s string) {
	m.contact_number = &s
}

// ContactNumber returns the value of the "contact_number" field in the mutation.
func (m *SellerShopMutation) ContactNumber() (r string, exists bool) {
	v := m.contact_number
	if v == nil {
		return
	}
	return *v, true
}

// OldContactNumber returns the old "contact_number" field's value of the SellerShop entity.
// If the SellerShop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerShopMutation) OldContactNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactNumber: %w", err)
	}
	return oldValue.ContactNumber, nil
}

// ResetContactNumber resets all changes to the "contact_number" field.
func (m *SellerShopMutation) ResetContactNumber() {
	m.contact_number = nil
}

// SetBanner sets the "banner" field.
func (m *SellerShopMutation) SetBanner(s string) {
	m.banner = &s
}

// Banner returns the value of the "banner" field in the mutation.
func (m *SellerShopMutation) Banner() (r string, exists bool) {
	v := m.banner
	if v == nil {
		return
	}
	return *v, true
}

// OldBanner returns the old "banner" field's value of the SellerShop entity.
// If the SellerShop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerShopMutation) OldBanner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBanner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBanner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanner: %w", err)
	}
	return oldValue.Banner, nil
}

// ResetBanner resets all changes to the "banner" field.
func (m *SellerShopMutation) ResetBanner() {
	m.banner = nil
}

// SetBusinessLocation sets the "business_location" field.
func (m *SellerShopMutation) SetBusinessLocation(s string) {
	m.business_location = &s
}

// BusinessLocation returns the value of the "business_location" field in the mutation.
func (m *SellerShopMutation) BusinessLocation() (r string, exists bool) {
	v := m.business_location
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessLocation returns the old "business_location" field's value of the SellerShop entity.
// If the SellerShop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerShopMutation) OldBusinessLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessLocation: %w", err)
	}
	return oldValue.BusinessLocation, nil
}

// ResetBusinessLocation resets all changes to the "business_location" field.
func (m *SellerShopMutation) ResetBusinessLocation() {
	m.business_location = nil
}

// SetTaxID sets the "tax_id" field.
func (m *SellerShopMutation) SetTaxID(s string) {
	m.tax_id = &s
}

// TaxID returns the value of the "tax_id" field in the mutation.
func (m *SellerShopMutation) TaxID() (r string, exists bool) {
	v := m.tax_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "tax_id" field's value of the SellerShop entity.
// If the SellerShop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerShopMutation) OldTaxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ResetTaxID resets all changes to the "tax_id" field.
func (m *SellerShopMutation) ResetTaxID() {
	m.tax_id = nil
}

// SetActive sets the "active" field.
func (m *SellerShopMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *SellerShopMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the SellerShop entity.
// If the SellerShop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerShopMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *SellerShopMutation) ResetActive() {
	m.active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SellerShopMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SellerShopMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SellerShop entity.
// If the SellerShop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerShopMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SellerShopMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SellerShopMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SellerShopMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SellerShop entity.
// If the SellerShop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerShopMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SellerShopMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SellerShopMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SellerShopMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SellerShop entity.
// If the SellerShop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerShopMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SellerShopMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sellershop.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SellerShopMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sellershop.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SellerShopMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sellershop.FieldDeletedAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SellerShopMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SellerShopMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SellerShopMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SellerShopMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SellerShopMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SellerShopMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAdminID sets the "admin" edge to the User entity by id.
func (m *SellerShopMutation) SetAdminID(id int) {
	m.admin = &id
}

// ClearAdmin clears the "admin" edge to the User entity.
func (m *SellerShopMutation) ClearAdmin() {
	m.clearedadmin = true
}

// AdminCleared reports if the "admin" edge to the User entity was cleared.
func (m *SellerShopMutation) AdminCleared() bool {
	return m.clearedadmin
}

// AdminID returns the "admin" edge ID in the mutation.
func (m *SellerShopMutation) AdminID() (id int, exists bool) {
	if m.admin != nil {
		return *m.admin, true
	}
	return
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *SellerShopMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *SellerShopMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// SetGetShopCategoryID sets the "get_shop_category" edge to the ShopCategory entity by id.
func (m *SellerShopMutation) SetGetShopCategoryID(id int) {
	m.get_shop_category = &id
}

// ClearGetShopCategory clears the "get_shop_category" edge to the ShopCategory entity.
func (m *SellerShopMutation) ClearGetShopCategory() {
	m.clearedget_shop_category = true
}

// GetShopCategoryCleared reports if the "get_shop_category" edge to the ShopCategory entity was cleared.
func (m *SellerShopMutation) GetShopCategoryCleared() bool {
	return m.clearedget_shop_category
}

// GetShopCategoryID returns the "get_shop_category" edge ID in the mutation.
func (m *SellerShopMutation) GetShopCategoryID() (id int, exists bool) {
	if m.get_shop_category != nil {
		return *m.get_shop_category, true
	}
	return
}

// GetShopCategoryIDs returns the "get_shop_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GetShopCategoryID instead. It exists only for internal usage by the builders.
func (m *SellerShopMutation) GetShopCategoryIDs() (ids []int) {
	if id := m.get_shop_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGetShopCategory resets all changes to the "get_shop_category" edge.
func (m *SellerShopMutation) ResetGetShopCategory() {
	m.get_shop_category = nil
	m.clearedget_shop_category = false
}

// AddSellerProductIDs adds the "seller_products" edge to the SellerProduct entity by ids.
func (m *SellerShopMutation) AddSellerProductIDs(ids ...int) {
	if m.seller_products == nil {
		m.seller_products = make(map[int]struct{})
	}
	for i := range ids {
		m.seller_products[ids[i]] = struct{}{}
	}
}

// ClearSellerProducts clears the "seller_products" edge to the SellerProduct entity.
func (m *SellerShopMutation) ClearSellerProducts() {
	m.clearedseller_products = true
}

// SellerProductsCleared reports if the "seller_products" edge to the SellerProduct entity was cleared.
func (m *SellerShopMutation) SellerProductsCleared() bool {
	return m.clearedseller_products
}

// RemoveSellerProductIDs removes the "seller_products" edge to the SellerProduct entity by IDs.
func (m *SellerShopMutation) RemoveSellerProductIDs(ids ...int) {
	if m.removedseller_products == nil {
		m.removedseller_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seller_products, ids[i])
		m.removedseller_products[ids[i]] = struct{}{}
	}
}

// RemovedSellerProducts returns the removed IDs of the "seller_products" edge to the SellerProduct entity.
func (m *SellerShopMutation) RemovedSellerProductsIDs() (ids []int) {
	for id := range m.removedseller_products {
		ids = append(ids, id)
	}
	return
}

// SellerProductsIDs returns the "seller_products" edge IDs in the mutation.
func (m *SellerShopMutation) SellerProductsIDs() (ids []int) {
	for id := range m.seller_products {
		ids = append(ids, id)
	}
	return
}

// ResetSellerProducts resets all changes to the "seller_products" edge.
func (m *SellerShopMutation) ResetSellerProducts() {
	m.seller_products = nil
	m.clearedseller_products = false
	m.removedseller_products = nil
}

// Where appends a list predicates to the SellerShopMutation builder.
func (m *SellerShopMutation) Where(ps ...predicate.SellerShop) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SellerShopMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SellerShop).
func (m *SellerShopMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SellerShopMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, sellershop.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, sellershop.FieldSlug)
	}
	if m.contact_number != nil {
		fields = append(fields, sellershop.FieldContactNumber)
	}
	if m.banner != nil {
		fields = append(fields, sellershop.FieldBanner)
	}
	if m.business_location != nil {
		fields = append(fields, sellershop.FieldBusinessLocation)
	}
	if m.tax_id != nil {
		fields = append(fields, sellershop.FieldTaxID)
	}
	if m.active != nil {
		fields = append(fields, sellershop.FieldActive)
	}
	if m.created_at != nil {
		fields = append(fields, sellershop.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sellershop.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sellershop.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SellerShopMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sellershop.FieldName:
		return m.Name()
	case sellershop.FieldSlug:
		return m.Slug()
	case sellershop.FieldContactNumber:
		return m.ContactNumber()
	case sellershop.FieldBanner:
		return m.Banner()
	case sellershop.FieldBusinessLocation:
		return m.BusinessLocation()
	case sellershop.FieldTaxID:
		return m.TaxID()
	case sellershop.FieldActive:
		return m.Active()
	case sellershop.FieldCreatedAt:
		return m.CreatedAt()
	case sellershop.FieldUpdatedAt:
		return m.UpdatedAt()
	case sellershop.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SellerShopMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sellershop.FieldName:
		return m.OldName(ctx)
	case sellershop.FieldSlug:
		return m.OldSlug(ctx)
	case sellershop.FieldContactNumber:
		return m.OldContactNumber(ctx)
	case sellershop.FieldBanner:
		return m.OldBanner(ctx)
	case sellershop.FieldBusinessLocation:
		return m.OldBusinessLocation(ctx)
	case sellershop.FieldTaxID:
		return m.OldTaxID(ctx)
	case sellershop.FieldActive:
		return m.OldActive(ctx)
	case sellershop.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sellershop.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sellershop.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SellerShop field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerShopMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sellershop.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sellershop.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case sellershop.FieldContactNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactNumber(v)
		return nil
	case sellershop.FieldBanner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanner(v)
		return nil
	case sellershop.FieldBusinessLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessLocation(v)
		return nil
	case sellershop.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	case sellershop.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case sellershop.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sellershop.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sellershop.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SellerShop field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SellerShopMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SellerShopMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerShopMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SellerShop numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SellerShopMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sellershop.FieldDeletedAt) {
		fields = append(fields, sellershop.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SellerShopMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SellerShopMutation) ClearField(name string) error {
	switch name {
	case sellershop.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerShop nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SellerShopMutation) ResetField(name string) error {
	switch name {
	case sellershop.FieldName:
		m.ResetName()
		return nil
	case sellershop.FieldSlug:
		m.ResetSlug()
		return nil
	case sellershop.FieldContactNumber:
		m.ResetContactNumber()
		return nil
	case sellershop.FieldBanner:
		m.ResetBanner()
		return nil
	case sellershop.FieldBusinessLocation:
		m.ResetBusinessLocation()
		return nil
	case sellershop.FieldTaxID:
		m.ResetTaxID()
		return nil
	case sellershop.FieldActive:
		m.ResetActive()
		return nil
	case sellershop.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sellershop.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sellershop.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SellerShop field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SellerShopMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, sellershop.EdgeUser)
	}
	if m.admin != nil {
		edges = append(edges, sellershop.EdgeAdmin)
	}
	if m.get_shop_category != nil {
		edges = append(edges, sellershop.EdgeGetShopCategory)
	}
	if m.seller_products != nil {
		edges = append(edges, sellershop.EdgeSellerProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SellerShopMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sellershop.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case sellershop.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case sellershop.EdgeGetShopCategory:
		if id := m.get_shop_category; id != nil {
			return []ent.Value{*id}
		}
	case sellershop.EdgeSellerProducts:
		ids := make([]ent.Value, 0, len(m.seller_products))
		for id := range m.seller_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SellerShopMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedseller_products != nil {
		edges = append(edges, sellershop.EdgeSellerProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SellerShopMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sellershop.EdgeSellerProducts:
		ids := make([]ent.Value, 0, len(m.removedseller_products))
		for id := range m.removedseller_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SellerShopMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, sellershop.EdgeUser)
	}
	if m.clearedadmin {
		edges = append(edges, sellershop.EdgeAdmin)
	}
	if m.clearedget_shop_category {
		edges = append(edges, sellershop.EdgeGetShopCategory)
	}
	if m.clearedseller_products {
		edges = append(edges, sellershop.EdgeSellerProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SellerShopMutation) EdgeCleared(name string) bool {
	switch name {
	case sellershop.EdgeUser:
		return m.cleareduser
	case sellershop.EdgeAdmin:
		return m.clearedadmin
	case sellershop.EdgeGetShopCategory:
		return m.clearedget_shop_category
	case sellershop.EdgeSellerProducts:
		return m.clearedseller_products
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SellerShopMutation) ClearEdge(name string) error {
	switch name {
	case sellershop.EdgeUser:
		m.ClearUser()
		return nil
	case sellershop.EdgeAdmin:
		m.ClearAdmin()
		return nil
	case sellershop.EdgeGetShopCategory:
		m.ClearGetShopCategory()
		return nil
	}
	return fmt.Errorf("unknown SellerShop unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SellerShopMutation) ResetEdge(name string) error {
	switch name {
	case sellershop.EdgeUser:
		m.ResetUser()
		return nil
	case sellershop.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case sellershop.EdgeGetShopCategory:
		m.ResetGetShopCategory()
		return nil
	case sellershop.EdgeSellerProducts:
		m.ResetSellerProducts()
		return nil
	}
	return fmt.Errorf("unknown SellerShop edge %s", name)
}

// ShopCategoryMutation represents an operation that mutates the ShopCategory nodes in the graph.
type ShopCategoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	slug                   *string
	image                  *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	clearedFields          map[string]struct{}
	categories             map[int]struct{}
	removedcategories      map[int]struct{}
	clearedcategories      bool
	seller_requests        map[int]struct{}
	removedseller_requests map[int]struct{}
	clearedseller_requests bool
	seller_shops           map[int]struct{}
	removedseller_shops    map[int]struct{}
	clearedseller_shops    bool
	done                   bool
	oldValue               func(context.Context) (*ShopCategory, error)
	predicates             []predicate.ShopCategory
}

var _ ent.Mutation = (*ShopCategoryMutation)(nil)

// shopcategoryOption allows management of the mutation configuration using functional options.
type shopcategoryOption func(*ShopCategoryMutation)

// newShopCategoryMutation creates new mutation for the ShopCategory entity.
func newShopCategoryMutation(c config, op Op, opts ...shopcategoryOption) *ShopCategoryMutation {
	m := &ShopCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeShopCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShopCategoryID sets the ID field of the mutation.
func withShopCategoryID(id int) shopcategoryOption {
	return func(m *ShopCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ShopCategory
		)
		m.oldValue = func(ctx context.Context) (*ShopCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShopCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShopCategory sets the old ShopCategory of the mutation.
func withShopCategory(node *ShopCategory) shopcategoryOption {
	return func(m *ShopCategoryMutation) {
		m.oldValue = func(context.Context) (*ShopCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShopCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShopCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShopCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShopCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShopCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ShopCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ShopCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ShopCategory entity.
// If the ShopCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ShopCategoryMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *ShopCategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ShopCategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the ShopCategory entity.
// If the ShopCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopCategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ShopCategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetImage sets the "image" field.
func (m *ShopCategoryMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *ShopCategoryMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the ShopCategory entity.
// If the ShopCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopCategoryMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *ShopCategoryMutation) ResetImage() {
	m.image = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ShopCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShopCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShopCategory entity.
// If the ShopCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShopCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShopCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShopCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShopCategory entity.
// If the ShopCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShopCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ShopCategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ShopCategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ShopCategory entity.
// If the ShopCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopCategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ShopCategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[shopcategory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ShopCategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[shopcategory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ShopCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, shopcategory.FieldDeletedAt)
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *ShopCategoryMutation) AddCategoryIDs(ids ...int) {
	if m.categories == nil {
		m.categories = make(map[int]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *ShopCategoryMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *ShopCategoryMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *ShopCategoryMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *ShopCategoryMutation) RemovedCategoriesIDs() (ids []int) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *ShopCategoryMutation) CategoriesIDs() (ids []int) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *ShopCategoryMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddSellerRequestIDs adds the "seller_requests" edge to the SellerRequest entity by ids.
func (m *ShopCategoryMutation) AddSellerRequestIDs(ids ...int) {
	if m.seller_requests == nil {
		m.seller_requests = make(map[int]struct{})
	}
	for i := range ids {
		m.seller_requests[ids[i]] = struct{}{}
	}
}

// ClearSellerRequests clears the "seller_requests" edge to the SellerRequest entity.
func (m *ShopCategoryMutation) ClearSellerRequests() {
	m.clearedseller_requests = true
}

// SellerRequestsCleared reports if the "seller_requests" edge to the SellerRequest entity was cleared.
func (m *ShopCategoryMutation) SellerRequestsCleared() bool {
	return m.clearedseller_requests
}

// RemoveSellerRequestIDs removes the "seller_requests" edge to the SellerRequest entity by IDs.
func (m *ShopCategoryMutation) RemoveSellerRequestIDs(ids ...int) {
	if m.removedseller_requests == nil {
		m.removedseller_requests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seller_requests, ids[i])
		m.removedseller_requests[ids[i]] = struct{}{}
	}
}

// RemovedSellerRequests returns the removed IDs of the "seller_requests" edge to the SellerRequest entity.
func (m *ShopCategoryMutation) RemovedSellerRequestsIDs() (ids []int) {
	for id := range m.removedseller_requests {
		ids = append(ids, id)
	}
	return
}

// SellerRequestsIDs returns the "seller_requests" edge IDs in the mutation.
func (m *ShopCategoryMutation) SellerRequestsIDs() (ids []int) {
	for id := range m.seller_requests {
		ids = append(ids, id)
	}
	return
}

// ResetSellerRequests resets all changes to the "seller_requests" edge.
func (m *ShopCategoryMutation) ResetSellerRequests() {
	m.seller_requests = nil
	m.clearedseller_requests = false
	m.removedseller_requests = nil
}

// AddSellerShopIDs adds the "seller_shops" edge to the SellerShop entity by ids.
func (m *ShopCategoryMutation) AddSellerShopIDs(ids ...int) {
	if m.seller_shops == nil {
		m.seller_shops = make(map[int]struct{})
	}
	for i := range ids {
		m.seller_shops[ids[i]] = struct{}{}
	}
}

// ClearSellerShops clears the "seller_shops" edge to the SellerShop entity.
func (m *ShopCategoryMutation) ClearSellerShops() {
	m.clearedseller_shops = true
}

// SellerShopsCleared reports if the "seller_shops" edge to the SellerShop entity was cleared.
func (m *ShopCategoryMutation) SellerShopsCleared() bool {
	return m.clearedseller_shops
}

// RemoveSellerShopIDs removes the "seller_shops" edge to the SellerShop entity by IDs.
func (m *ShopCategoryMutation) RemoveSellerShopIDs(ids ...int) {
	if m.removedseller_shops == nil {
		m.removedseller_shops = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seller_shops, ids[i])
		m.removedseller_shops[ids[i]] = struct{}{}
	}
}

// RemovedSellerShops returns the removed IDs of the "seller_shops" edge to the SellerShop entity.
func (m *ShopCategoryMutation) RemovedSellerShopsIDs() (ids []int) {
	for id := range m.removedseller_shops {
		ids = append(ids, id)
	}
	return
}

// SellerShopsIDs returns the "seller_shops" edge IDs in the mutation.
func (m *ShopCategoryMutation) SellerShopsIDs() (ids []int) {
	for id := range m.seller_shops {
		ids = append(ids, id)
	}
	return
}

// ResetSellerShops resets all changes to the "seller_shops" edge.
func (m *ShopCategoryMutation) ResetSellerShops() {
	m.seller_shops = nil
	m.clearedseller_shops = false
	m.removedseller_shops = nil
}

// Where appends a list predicates to the ShopCategoryMutation builder.
func (m *ShopCategoryMutation) Where(ps ...predicate.ShopCategory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ShopCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShopCategory).
func (m *ShopCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShopCategoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, shopcategory.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, shopcategory.FieldSlug)
	}
	if m.image != nil {
		fields = append(fields, shopcategory.FieldImage)
	}
	if m.created_at != nil {
		fields = append(fields, shopcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shopcategory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, shopcategory.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShopCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shopcategory.FieldName:
		return m.Name()
	case shopcategory.FieldSlug:
		return m.Slug()
	case shopcategory.FieldImage:
		return m.Image()
	case shopcategory.FieldCreatedAt:
		return m.CreatedAt()
	case shopcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case shopcategory.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShopCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shopcategory.FieldName:
		return m.OldName(ctx)
	case shopcategory.FieldSlug:
		return m.OldSlug(ctx)
	case shopcategory.FieldImage:
		return m.OldImage(ctx)
	case shopcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shopcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shopcategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ShopCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShopCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shopcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case shopcategory.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case shopcategory.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case shopcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shopcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shopcategory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ShopCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShopCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShopCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShopCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShopCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShopCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shopcategory.FieldDeletedAt) {
		fields = append(fields, shopcategory.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShopCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShopCategoryMutation) ClearField(name string) error {
	switch name {
	case shopcategory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ShopCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShopCategoryMutation) ResetField(name string) error {
	switch name {
	case shopcategory.FieldName:
		m.ResetName()
		return nil
	case shopcategory.FieldSlug:
		m.ResetSlug()
		return nil
	case shopcategory.FieldImage:
		m.ResetImage()
		return nil
	case shopcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shopcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shopcategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ShopCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShopCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.categories != nil {
		edges = append(edges, shopcategory.EdgeCategories)
	}
	if m.seller_requests != nil {
		edges = append(edges, shopcategory.EdgeSellerRequests)
	}
	if m.seller_shops != nil {
		edges = append(edges, shopcategory.EdgeSellerShops)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShopCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shopcategory.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case shopcategory.EdgeSellerRequests:
		ids := make([]ent.Value, 0, len(m.seller_requests))
		for id := range m.seller_requests {
			ids = append(ids, id)
		}
		return ids
	case shopcategory.EdgeSellerShops:
		ids := make([]ent.Value, 0, len(m.seller_shops))
		for id := range m.seller_shops {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShopCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcategories != nil {
		edges = append(edges, shopcategory.EdgeCategories)
	}
	if m.removedseller_requests != nil {
		edges = append(edges, shopcategory.EdgeSellerRequests)
	}
	if m.removedseller_shops != nil {
		edges = append(edges, shopcategory.EdgeSellerShops)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShopCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case shopcategory.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case shopcategory.EdgeSellerRequests:
		ids := make([]ent.Value, 0, len(m.removedseller_requests))
		for id := range m.removedseller_requests {
			ids = append(ids, id)
		}
		return ids
	case shopcategory.EdgeSellerShops:
		ids := make([]ent.Value, 0, len(m.removedseller_shops))
		for id := range m.removedseller_shops {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShopCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcategories {
		edges = append(edges, shopcategory.EdgeCategories)
	}
	if m.clearedseller_requests {
		edges = append(edges, shopcategory.EdgeSellerRequests)
	}
	if m.clearedseller_shops {
		edges = append(edges, shopcategory.EdgeSellerShops)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShopCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case shopcategory.EdgeCategories:
		return m.clearedcategories
	case shopcategory.EdgeSellerRequests:
		return m.clearedseller_requests
	case shopcategory.EdgeSellerShops:
		return m.clearedseller_shops
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShopCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ShopCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShopCategoryMutation) ResetEdge(name string) error {
	switch name {
	case shopcategory.EdgeCategories:
		m.ResetCategories()
		return nil
	case shopcategory.EdgeSellerRequests:
		m.ResetSellerRequests()
		return nil
	case shopcategory.EdgeSellerShops:
		m.ResetSellerShops()
		return nil
	}
	return fmt.Errorf("unknown ShopCategory edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	name                            *string
	phone_number                    *string
	password                        *string
	admin                           *bool
	staff                           *bool
	seller                          *bool
	active                          *bool
	admin_user_name                 *string
	admin_user_token                *string
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	clearedFields                   map[string]struct{}
	seller_requests                 map[int]struct{}
	removedseller_requests          map[int]struct{}
	clearedseller_requests          bool
	seller_shops                    map[int]struct{}
	removedseller_shops             map[int]struct{}
	clearedseller_shops             bool
	seller_products                 map[int]struct{}
	removedseller_products          map[int]struct{}
	clearedseller_products          bool
	carts                           map[int]struct{}
	removedcarts                    map[int]struct{}
	clearedcarts                    bool
	user_locations                  map[int]struct{}
	removeduser_locations           map[int]struct{}
	cleareduser_locations           bool
	checkouts                       map[int]struct{}
	removedcheckouts                map[int]struct{}
	clearedcheckouts                bool
	checkout_products               map[int]struct{}
	removedcheckout_products        map[int]struct{}
	clearedcheckout_products        bool
	seller_checkout_products        map[int]struct{}
	removedseller_checkout_products map[int]struct{}
	clearedseller_checkout_products bool
	approved_shops                  map[int]struct{}
	removedapproved_shops           map[int]struct{}
	clearedapproved_shops           bool
	done                            bool
	oldValue                        func(context.Context) (*User, error)
	predicates                      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetAdmin sets the "admin" field.
func (m *UserMutation) SetAdmin(b bool) {
	m.admin = &b
}

// Admin returns the value of the "admin" field in the mutation.
func (m *UserMutation) Admin() (r bool, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmin returns the old "admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmin: %w", err)
	}
	return oldValue.Admin, nil
}

// ResetAdmin resets all changes to the "admin" field.
func (m *UserMutation) ResetAdmin() {
	m.admin = nil
}

// SetStaff sets the "staff" field.
func (m *UserMutation) SetStaff(b bool) {
	m.staff = &b
}

// Staff returns the value of the "staff" field in the mutation.
func (m *UserMutation) Staff() (r bool, exists bool) {
	v := m.staff
	if v == nil {
		return
	}
	return *v, true
}

// OldStaff returns the old "staff" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStaff(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStaff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStaff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaff: %w", err)
	}
	return oldValue.Staff, nil
}

// ResetStaff resets all changes to the "staff" field.
func (m *UserMutation) ResetStaff() {
	m.staff = nil
}

// SetSeller sets the "seller" field.
func (m *UserMutation) SetSeller(b bool) {
	m.seller = &b
}

// Seller returns the value of the "seller" field in the mutation.
func (m *UserMutation) Seller() (r bool, exists bool) {
	v := m.seller
	if v == nil {
		return
	}
	return *v, true
}

// OldSeller returns the old "seller" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSeller(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeller: %w", err)
	}
	return oldValue.Seller, nil
}

// ResetSeller resets all changes to the "seller" field.
func (m *UserMutation) ResetSeller() {
	m.seller = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetAdminUserName sets the "admin_user_name" field.
func (m *UserMutation) SetAdminUserName(s string) {
	m.admin_user_name = &s
}

// AdminUserName returns the value of the "admin_user_name" field in the mutation.
func (m *UserMutation) AdminUserName() (r string, exists bool) {
	v := m.admin_user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminUserName returns the old "admin_user_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAdminUserName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminUserName: %w", err)
	}
	return oldValue.AdminUserName, nil
}

// ClearAdminUserName clears the value of the "admin_user_name" field.
func (m *UserMutation) ClearAdminUserName() {
	m.admin_user_name = nil
	m.clearedFields[user.FieldAdminUserName] = struct{}{}
}

// AdminUserNameCleared returns if the "admin_user_name" field was cleared in this mutation.
func (m *UserMutation) AdminUserNameCleared() bool {
	_, ok := m.clearedFields[user.FieldAdminUserName]
	return ok
}

// ResetAdminUserName resets all changes to the "admin_user_name" field.
func (m *UserMutation) ResetAdminUserName() {
	m.admin_user_name = nil
	delete(m.clearedFields, user.FieldAdminUserName)
}

// SetAdminUserToken sets the "admin_user_token" field.
func (m *UserMutation) SetAdminUserToken(s string) {
	m.admin_user_token = &s
}

// AdminUserToken returns the value of the "admin_user_token" field in the mutation.
func (m *UserMutation) AdminUserToken() (r string, exists bool) {
	v := m.admin_user_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminUserToken returns the old "admin_user_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAdminUserToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminUserToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminUserToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminUserToken: %w", err)
	}
	return oldValue.AdminUserToken, nil
}

// ClearAdminUserToken clears the value of the "admin_user_token" field.
func (m *UserMutation) ClearAdminUserToken() {
	m.admin_user_token = nil
	m.clearedFields[user.FieldAdminUserToken] = struct{}{}
}

// AdminUserTokenCleared returns if the "admin_user_token" field was cleared in this mutation.
func (m *UserMutation) AdminUserTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldAdminUserToken]
	return ok
}

// ResetAdminUserToken resets all changes to the "admin_user_token" field.
func (m *UserMutation) ResetAdminUserToken() {
	m.admin_user_token = nil
	delete(m.clearedFields, user.FieldAdminUserToken)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// AddSellerRequestIDs adds the "seller_requests" edge to the SellerRequest entity by ids.
func (m *UserMutation) AddSellerRequestIDs(ids ...int) {
	if m.seller_requests == nil {
		m.seller_requests = make(map[int]struct{})
	}
	for i := range ids {
		m.seller_requests[ids[i]] = struct{}{}
	}
}

// ClearSellerRequests clears the "seller_requests" edge to the SellerRequest entity.
func (m *UserMutation) ClearSellerRequests() {
	m.clearedseller_requests = true
}

// SellerRequestsCleared reports if the "seller_requests" edge to the SellerRequest entity was cleared.
func (m *UserMutation) SellerRequestsCleared() bool {
	return m.clearedseller_requests
}

// RemoveSellerRequestIDs removes the "seller_requests" edge to the SellerRequest entity by IDs.
func (m *UserMutation) RemoveSellerRequestIDs(ids ...int) {
	if m.removedseller_requests == nil {
		m.removedseller_requests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seller_requests, ids[i])
		m.removedseller_requests[ids[i]] = struct{}{}
	}
}

// RemovedSellerRequests returns the removed IDs of the "seller_requests" edge to the SellerRequest entity.
func (m *UserMutation) RemovedSellerRequestsIDs() (ids []int) {
	for id := range m.removedseller_requests {
		ids = append(ids, id)
	}
	return
}

// SellerRequestsIDs returns the "seller_requests" edge IDs in the mutation.
func (m *UserMutation) SellerRequestsIDs() (ids []int) {
	for id := range m.seller_requests {
		ids = append(ids, id)
	}
	return
}

// ResetSellerRequests resets all changes to the "seller_requests" edge.
func (m *UserMutation) ResetSellerRequests() {
	m.seller_requests = nil
	m.clearedseller_requests = false
	m.removedseller_requests = nil
}

// AddSellerShopIDs adds the "seller_shops" edge to the SellerShop entity by ids.
func (m *UserMutation) AddSellerShopIDs(ids ...int) {
	if m.seller_shops == nil {
		m.seller_shops = make(map[int]struct{})
	}
	for i := range ids {
		m.seller_shops[ids[i]] = struct{}{}
	}
}

// ClearSellerShops clears the "seller_shops" edge to the SellerShop entity.
func (m *UserMutation) ClearSellerShops() {
	m.clearedseller_shops = true
}

// SellerShopsCleared reports if the "seller_shops" edge to the SellerShop entity was cleared.
func (m *UserMutation) SellerShopsCleared() bool {
	return m.clearedseller_shops
}

// RemoveSellerShopIDs removes the "seller_shops" edge to the SellerShop entity by IDs.
func (m *UserMutation) RemoveSellerShopIDs(ids ...int) {
	if m.removedseller_shops == nil {
		m.removedseller_shops = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seller_shops, ids[i])
		m.removedseller_shops[ids[i]] = struct{}{}
	}
}

// RemovedSellerShops returns the removed IDs of the "seller_shops" edge to the SellerShop entity.
func (m *UserMutation) RemovedSellerShopsIDs() (ids []int) {
	for id := range m.removedseller_shops {
		ids = append(ids, id)
	}
	return
}

// SellerShopsIDs returns the "seller_shops" edge IDs in the mutation.
func (m *UserMutation) SellerShopsIDs() (ids []int) {
	for id := range m.seller_shops {
		ids = append(ids, id)
	}
	return
}

// ResetSellerShops resets all changes to the "seller_shops" edge.
func (m *UserMutation) ResetSellerShops() {
	m.seller_shops = nil
	m.clearedseller_shops = false
	m.removedseller_shops = nil
}

// AddSellerProductIDs adds the "seller_products" edge to the SellerProduct entity by ids.
func (m *UserMutation) AddSellerProductIDs(ids ...int) {
	if m.seller_products == nil {
		m.seller_products = make(map[int]struct{})
	}
	for i := range ids {
		m.seller_products[ids[i]] = struct{}{}
	}
}

// ClearSellerProducts clears the "seller_products" edge to the SellerProduct entity.
func (m *UserMutation) ClearSellerProducts() {
	m.clearedseller_products = true
}

// SellerProductsCleared reports if the "seller_products" edge to the SellerProduct entity was cleared.
func (m *UserMutation) SellerProductsCleared() bool {
	return m.clearedseller_products
}

// RemoveSellerProductIDs removes the "seller_products" edge to the SellerProduct entity by IDs.
func (m *UserMutation) RemoveSellerProductIDs(ids ...int) {
	if m.removedseller_products == nil {
		m.removedseller_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seller_products, ids[i])
		m.removedseller_products[ids[i]] = struct{}{}
	}
}

// RemovedSellerProducts returns the removed IDs of the "seller_products" edge to the SellerProduct entity.
func (m *UserMutation) RemovedSellerProductsIDs() (ids []int) {
	for id := range m.removedseller_products {
		ids = append(ids, id)
	}
	return
}

// SellerProductsIDs returns the "seller_products" edge IDs in the mutation.
func (m *UserMutation) SellerProductsIDs() (ids []int) {
	for id := range m.seller_products {
		ids = append(ids, id)
	}
	return
}

// ResetSellerProducts resets all changes to the "seller_products" edge.
func (m *UserMutation) ResetSellerProducts() {
	m.seller_products = nil
	m.clearedseller_products = false
	m.removedseller_products = nil
}

// AddCartIDs adds the "carts" edge to the Cart entity by ids.
func (m *UserMutation) AddCartIDs(ids ...int) {
	if m.carts == nil {
		m.carts = make(map[int]struct{})
	}
	for i := range ids {
		m.carts[ids[i]] = struct{}{}
	}
}

// ClearCarts clears the "carts" edge to the Cart entity.
func (m *UserMutation) ClearCarts() {
	m.clearedcarts = true
}

// CartsCleared reports if the "carts" edge to the Cart entity was cleared.
func (m *UserMutation) CartsCleared() bool {
	return m.clearedcarts
}

// RemoveCartIDs removes the "carts" edge to the Cart entity by IDs.
func (m *UserMutation) RemoveCartIDs(ids ...int) {
	if m.removedcarts == nil {
		m.removedcarts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.carts, ids[i])
		m.removedcarts[ids[i]] = struct{}{}
	}
}

// RemovedCarts returns the removed IDs of the "carts" edge to the Cart entity.
func (m *UserMutation) RemovedCartsIDs() (ids []int) {
	for id := range m.removedcarts {
		ids = append(ids, id)
	}
	return
}

// CartsIDs returns the "carts" edge IDs in the mutation.
func (m *UserMutation) CartsIDs() (ids []int) {
	for id := range m.carts {
		ids = append(ids, id)
	}
	return
}

// ResetCarts resets all changes to the "carts" edge.
func (m *UserMutation) ResetCarts() {
	m.carts = nil
	m.clearedcarts = false
	m.removedcarts = nil
}

// AddUserLocationIDs adds the "user_locations" edge to the UserLocation entity by ids.
func (m *UserMutation) AddUserLocationIDs(ids ...int) {
	if m.user_locations == nil {
		m.user_locations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_locations[ids[i]] = struct{}{}
	}
}

// ClearUserLocations clears the "user_locations" edge to the UserLocation entity.
func (m *UserMutation) ClearUserLocations() {
	m.cleareduser_locations = true
}

// UserLocationsCleared reports if the "user_locations" edge to the UserLocation entity was cleared.
func (m *UserMutation) UserLocationsCleared() bool {
	return m.cleareduser_locations
}

// RemoveUserLocationIDs removes the "user_locations" edge to the UserLocation entity by IDs.
func (m *UserMutation) RemoveUserLocationIDs(ids ...int) {
	if m.removeduser_locations == nil {
		m.removeduser_locations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_locations, ids[i])
		m.removeduser_locations[ids[i]] = struct{}{}
	}
}

// RemovedUserLocations returns the removed IDs of the "user_locations" edge to the UserLocation entity.
func (m *UserMutation) RemovedUserLocationsIDs() (ids []int) {
	for id := range m.removeduser_locations {
		ids = append(ids, id)
	}
	return
}

// UserLocationsIDs returns the "user_locations" edge IDs in the mutation.
func (m *UserMutation) UserLocationsIDs() (ids []int) {
	for id := range m.user_locations {
		ids = append(ids, id)
	}
	return
}

// ResetUserLocations resets all changes to the "user_locations" edge.
func (m *UserMutation) ResetUserLocations() {
	m.user_locations = nil
	m.cleareduser_locations = false
	m.removeduser_locations = nil
}

// AddCheckoutIDs adds the "checkouts" edge to the Checkout entity by ids.
func (m *UserMutation) AddCheckoutIDs(ids ...int) {
	if m.checkouts == nil {
		m.checkouts = make(map[int]struct{})
	}
	for i := range ids {
		m.checkouts[ids[i]] = struct{}{}
	}
}

// ClearCheckouts clears the "checkouts" edge to the Checkout entity.
func (m *UserMutation) ClearCheckouts() {
	m.clearedcheckouts = true
}

// CheckoutsCleared reports if the "checkouts" edge to the Checkout entity was cleared.
func (m *UserMutation) CheckoutsCleared() bool {
	return m.clearedcheckouts
}

// RemoveCheckoutIDs removes the "checkouts" edge to the Checkout entity by IDs.
func (m *UserMutation) RemoveCheckoutIDs(ids ...int) {
	if m.removedcheckouts == nil {
		m.removedcheckouts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.checkouts, ids[i])
		m.removedcheckouts[ids[i]] = struct{}{}
	}
}

// RemovedCheckouts returns the removed IDs of the "checkouts" edge to the Checkout entity.
func (m *UserMutation) RemovedCheckoutsIDs() (ids []int) {
	for id := range m.removedcheckouts {
		ids = append(ids, id)
	}
	return
}

// CheckoutsIDs returns the "checkouts" edge IDs in the mutation.
func (m *UserMutation) CheckoutsIDs() (ids []int) {
	for id := range m.checkouts {
		ids = append(ids, id)
	}
	return
}

// ResetCheckouts resets all changes to the "checkouts" edge.
func (m *UserMutation) ResetCheckouts() {
	m.checkouts = nil
	m.clearedcheckouts = false
	m.removedcheckouts = nil
}

// AddCheckoutProductIDs adds the "checkout_products" edge to the CheckoutProduct entity by ids.
func (m *UserMutation) AddCheckoutProductIDs(ids ...int) {
	if m.checkout_products == nil {
		m.checkout_products = make(map[int]struct{})
	}
	for i := range ids {
		m.checkout_products[ids[i]] = struct{}{}
	}
}

// ClearCheckoutProducts clears the "checkout_products" edge to the CheckoutProduct entity.
func (m *UserMutation) ClearCheckoutProducts() {
	m.clearedcheckout_products = true
}

// CheckoutProductsCleared reports if the "checkout_products" edge to the CheckoutProduct entity was cleared.
func (m *UserMutation) CheckoutProductsCleared() bool {
	return m.clearedcheckout_products
}

// RemoveCheckoutProductIDs removes the "checkout_products" edge to the CheckoutProduct entity by IDs.
func (m *UserMutation) RemoveCheckoutProductIDs(ids ...int) {
	if m.removedcheckout_products == nil {
		m.removedcheckout_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.checkout_products, ids[i])
		m.removedcheckout_products[ids[i]] = struct{}{}
	}
}

// RemovedCheckoutProducts returns the removed IDs of the "checkout_products" edge to the CheckoutProduct entity.
func (m *UserMutation) RemovedCheckoutProductsIDs() (ids []int) {
	for id := range m.removedcheckout_products {
		ids = append(ids, id)
	}
	return
}

// CheckoutProductsIDs returns the "checkout_products" edge IDs in the mutation.
func (m *UserMutation) CheckoutProductsIDs() (ids []int) {
	for id := range m.checkout_products {
		ids = append(ids, id)
	}
	return
}

// ResetCheckoutProducts resets all changes to the "checkout_products" edge.
func (m *UserMutation) ResetCheckoutProducts() {
	m.checkout_products = nil
	m.clearedcheckout_products = false
	m.removedcheckout_products = nil
}

// AddSellerCheckoutProductIDs adds the "seller_checkout_products" edge to the CheckoutProduct entity by ids.
func (m *UserMutation) AddSellerCheckoutProductIDs(ids ...int) {
	if m.seller_checkout_products == nil {
		m.seller_checkout_products = make(map[int]struct{})
	}
	for i := range ids {
		m.seller_checkout_products[ids[i]] = struct{}{}
	}
}

// ClearSellerCheckoutProducts clears the "seller_checkout_products" edge to the CheckoutProduct entity.
func (m *UserMutation) ClearSellerCheckoutProducts() {
	m.clearedseller_checkout_products = true
}

// SellerCheckoutProductsCleared reports if the "seller_checkout_products" edge to the CheckoutProduct entity was cleared.
func (m *UserMutation) SellerCheckoutProductsCleared() bool {
	return m.clearedseller_checkout_products
}

// RemoveSellerCheckoutProductIDs removes the "seller_checkout_products" edge to the CheckoutProduct entity by IDs.
func (m *UserMutation) RemoveSellerCheckoutProductIDs(ids ...int) {
	if m.removedseller_checkout_products == nil {
		m.removedseller_checkout_products = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seller_checkout_products, ids[i])
		m.removedseller_checkout_products[ids[i]] = struct{}{}
	}
}

// RemovedSellerCheckoutProducts returns the removed IDs of the "seller_checkout_products" edge to the CheckoutProduct entity.
func (m *UserMutation) RemovedSellerCheckoutProductsIDs() (ids []int) {
	for id := range m.removedseller_checkout_products {
		ids = append(ids, id)
	}
	return
}

// SellerCheckoutProductsIDs returns the "seller_checkout_products" edge IDs in the mutation.
func (m *UserMutation) SellerCheckoutProductsIDs() (ids []int) {
	for id := range m.seller_checkout_products {
		ids = append(ids, id)
	}
	return
}

// ResetSellerCheckoutProducts resets all changes to the "seller_checkout_products" edge.
func (m *UserMutation) ResetSellerCheckoutProducts() {
	m.seller_checkout_products = nil
	m.clearedseller_checkout_products = false
	m.removedseller_checkout_products = nil
}

// AddApprovedShopIDs adds the "approved_shops" edge to the SellerShop entity by ids.
func (m *UserMutation) AddApprovedShopIDs(ids ...int) {
	if m.approved_shops == nil {
		m.approved_shops = make(map[int]struct{})
	}
	for i := range ids {
		m.approved_shops[ids[i]] = struct{}{}
	}
}

// ClearApprovedShops clears the "approved_shops" edge to the SellerShop entity.
func (m *UserMutation) ClearApprovedShops() {
	m.clearedapproved_shops = true
}

// ApprovedShopsCleared reports if the "approved_shops" edge to the SellerShop entity was cleared.
func (m *UserMutation) ApprovedShopsCleared() bool {
	return m.clearedapproved_shops
}

// RemoveApprovedShopIDs removes the "approved_shops" edge to the SellerShop entity by IDs.
func (m *UserMutation) RemoveApprovedShopIDs(ids ...int) {
	if m.removedapproved_shops == nil {
		m.removedapproved_shops = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.approved_shops, ids[i])
		m.removedapproved_shops[ids[i]] = struct{}{}
	}
}

// RemovedApprovedShops returns the removed IDs of the "approved_shops" edge to the SellerShop entity.
func (m *UserMutation) RemovedApprovedShopsIDs() (ids []int) {
	for id := range m.removedapproved_shops {
		ids = append(ids, id)
	}
	return
}

// ApprovedShopsIDs returns the "approved_shops" edge IDs in the mutation.
func (m *UserMutation) ApprovedShopsIDs() (ids []int) {
	for id := range m.approved_shops {
		ids = append(ids, id)
	}
	return
}

// ResetApprovedShops resets all changes to the "approved_shops" edge.
func (m *UserMutation) ResetApprovedShops() {
	m.approved_shops = nil
	m.clearedapproved_shops = false
	m.removedapproved_shops = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.admin != nil {
		fields = append(fields, user.FieldAdmin)
	}
	if m.staff != nil {
		fields = append(fields, user.FieldStaff)
	}
	if m.seller != nil {
		fields = append(fields, user.FieldSeller)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.admin_user_name != nil {
		fields = append(fields, user.FieldAdminUserName)
	}
	if m.admin_user_token != nil {
		fields = append(fields, user.FieldAdminUserToken)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldPassword:
		return m.Password()
	case user.FieldAdmin:
		return m.Admin()
	case user.FieldStaff:
		return m.Staff()
	case user.FieldSeller:
		return m.Seller()
	case user.FieldActive:
		return m.Active()
	case user.FieldAdminUserName:
		return m.AdminUserName()
	case user.FieldAdminUserToken:
		return m.AdminUserToken()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldAdmin:
		return m.OldAdmin(ctx)
	case user.FieldStaff:
		return m.OldStaff(ctx)
	case user.FieldSeller:
		return m.OldSeller(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldAdminUserName:
		return m.OldAdminUserName(ctx)
	case user.FieldAdminUserToken:
		return m.OldAdminUserToken(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmin(v)
		return nil
	case user.FieldStaff:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaff(v)
		return nil
	case user.FieldSeller:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeller(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldAdminUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminUserName(v)
		return nil
	case user.FieldAdminUserToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminUserToken(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAdminUserName) {
		fields = append(fields, user.FieldAdminUserName)
	}
	if m.FieldCleared(user.FieldAdminUserToken) {
		fields = append(fields, user.FieldAdminUserToken)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAdminUserName:
		m.ClearAdminUserName()
		return nil
	case user.FieldAdminUserToken:
		m.ClearAdminUserToken()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldAdmin:
		m.ResetAdmin()
		return nil
	case user.FieldStaff:
		m.ResetStaff()
		return nil
	case user.FieldSeller:
		m.ResetSeller()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldAdminUserName:
		m.ResetAdminUserName()
		return nil
	case user.FieldAdminUserToken:
		m.ResetAdminUserToken()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.seller_requests != nil {
		edges = append(edges, user.EdgeSellerRequests)
	}
	if m.seller_shops != nil {
		edges = append(edges, user.EdgeSellerShops)
	}
	if m.seller_products != nil {
		edges = append(edges, user.EdgeSellerProducts)
	}
	if m.carts != nil {
		edges = append(edges, user.EdgeCarts)
	}
	if m.user_locations != nil {
		edges = append(edges, user.EdgeUserLocations)
	}
	if m.checkouts != nil {
		edges = append(edges, user.EdgeCheckouts)
	}
	if m.checkout_products != nil {
		edges = append(edges, user.EdgeCheckoutProducts)
	}
	if m.seller_checkout_products != nil {
		edges = append(edges, user.EdgeSellerCheckoutProducts)
	}
	if m.approved_shops != nil {
		edges = append(edges, user.EdgeApprovedShops)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSellerRequests:
		ids := make([]ent.Value, 0, len(m.seller_requests))
		for id := range m.seller_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSellerShops:
		ids := make([]ent.Value, 0, len(m.seller_shops))
		for id := range m.seller_shops {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSellerProducts:
		ids := make([]ent.Value, 0, len(m.seller_products))
		for id := range m.seller_products {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCarts:
		ids := make([]ent.Value, 0, len(m.carts))
		for id := range m.carts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserLocations:
		ids := make([]ent.Value, 0, len(m.user_locations))
		for id := range m.user_locations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCheckouts:
		ids := make([]ent.Value, 0, len(m.checkouts))
		for id := range m.checkouts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCheckoutProducts:
		ids := make([]ent.Value, 0, len(m.checkout_products))
		for id := range m.checkout_products {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSellerCheckoutProducts:
		ids := make([]ent.Value, 0, len(m.seller_checkout_products))
		for id := range m.seller_checkout_products {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApprovedShops:
		ids := make([]ent.Value, 0, len(m.approved_shops))
		for id := range m.approved_shops {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedseller_requests != nil {
		edges = append(edges, user.EdgeSellerRequests)
	}
	if m.removedseller_shops != nil {
		edges = append(edges, user.EdgeSellerShops)
	}
	if m.removedseller_products != nil {
		edges = append(edges, user.EdgeSellerProducts)
	}
	if m.removedcarts != nil {
		edges = append(edges, user.EdgeCarts)
	}
	if m.removeduser_locations != nil {
		edges = append(edges, user.EdgeUserLocations)
	}
	if m.removedcheckouts != nil {
		edges = append(edges, user.EdgeCheckouts)
	}
	if m.removedcheckout_products != nil {
		edges = append(edges, user.EdgeCheckoutProducts)
	}
	if m.removedseller_checkout_products != nil {
		edges = append(edges, user.EdgeSellerCheckoutProducts)
	}
	if m.removedapproved_shops != nil {
		edges = append(edges, user.EdgeApprovedShops)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSellerRequests:
		ids := make([]ent.Value, 0, len(m.removedseller_requests))
		for id := range m.removedseller_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSellerShops:
		ids := make([]ent.Value, 0, len(m.removedseller_shops))
		for id := range m.removedseller_shops {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSellerProducts:
		ids := make([]ent.Value, 0, len(m.removedseller_products))
		for id := range m.removedseller_products {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCarts:
		ids := make([]ent.Value, 0, len(m.removedcarts))
		for id := range m.removedcarts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserLocations:
		ids := make([]ent.Value, 0, len(m.removeduser_locations))
		for id := range m.removeduser_locations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCheckouts:
		ids := make([]ent.Value, 0, len(m.removedcheckouts))
		for id := range m.removedcheckouts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCheckoutProducts:
		ids := make([]ent.Value, 0, len(m.removedcheckout_products))
		for id := range m.removedcheckout_products {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSellerCheckoutProducts:
		ids := make([]ent.Value, 0, len(m.removedseller_checkout_products))
		for id := range m.removedseller_checkout_products {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApprovedShops:
		ids := make([]ent.Value, 0, len(m.removedapproved_shops))
		for id := range m.removedapproved_shops {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedseller_requests {
		edges = append(edges, user.EdgeSellerRequests)
	}
	if m.clearedseller_shops {
		edges = append(edges, user.EdgeSellerShops)
	}
	if m.clearedseller_products {
		edges = append(edges, user.EdgeSellerProducts)
	}
	if m.clearedcarts {
		edges = append(edges, user.EdgeCarts)
	}
	if m.cleareduser_locations {
		edges = append(edges, user.EdgeUserLocations)
	}
	if m.clearedcheckouts {
		edges = append(edges, user.EdgeCheckouts)
	}
	if m.clearedcheckout_products {
		edges = append(edges, user.EdgeCheckoutProducts)
	}
	if m.clearedseller_checkout_products {
		edges = append(edges, user.EdgeSellerCheckoutProducts)
	}
	if m.clearedapproved_shops {
		edges = append(edges, user.EdgeApprovedShops)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSellerRequests:
		return m.clearedseller_requests
	case user.EdgeSellerShops:
		return m.clearedseller_shops
	case user.EdgeSellerProducts:
		return m.clearedseller_products
	case user.EdgeCarts:
		return m.clearedcarts
	case user.EdgeUserLocations:
		return m.cleareduser_locations
	case user.EdgeCheckouts:
		return m.clearedcheckouts
	case user.EdgeCheckoutProducts:
		return m.clearedcheckout_products
	case user.EdgeSellerCheckoutProducts:
		return m.clearedseller_checkout_products
	case user.EdgeApprovedShops:
		return m.clearedapproved_shops
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSellerRequests:
		m.ResetSellerRequests()
		return nil
	case user.EdgeSellerShops:
		m.ResetSellerShops()
		return nil
	case user.EdgeSellerProducts:
		m.ResetSellerProducts()
		return nil
	case user.EdgeCarts:
		m.ResetCarts()
		return nil
	case user.EdgeUserLocations:
		m.ResetUserLocations()
		return nil
	case user.EdgeCheckouts:
		m.ResetCheckouts()
		return nil
	case user.EdgeCheckoutProducts:
		m.ResetCheckoutProducts()
		return nil
	case user.EdgeSellerCheckoutProducts:
		m.ResetSellerCheckoutProducts()
		return nil
	case user.EdgeApprovedShops:
		m.ResetApprovedShops()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserLocationMutation represents an operation that mutates the UserLocation nodes in the graph.
type UserLocationMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	area                  *string
	street                *string
	house                 *string
	post_office           *string
	post_code             *int
	addpost_code          *int
	police_station        *string
	city                  *string
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	clearedFields         map[string]struct{}
	get_user              *int
	clearedget_user       bool
	user_locations        map[int]struct{}
	removeduser_locations map[int]struct{}
	cleareduser_locations bool
	done                  bool
	oldValue              func(context.Context) (*UserLocation, error)
	predicates            []predicate.UserLocation
}

var _ ent.Mutation = (*UserLocationMutation)(nil)

// userlocationOption allows management of the mutation configuration using functional options.
type userlocationOption func(*UserLocationMutation)

// newUserLocationMutation creates new mutation for the UserLocation entity.
func newUserLocationMutation(c config, op Op, opts ...userlocationOption) *UserLocationMutation {
	m := &UserLocationMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLocationID sets the ID field of the mutation.
func withUserLocationID(id int) userlocationOption {
	return func(m *UserLocationMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLocation
		)
		m.oldValue = func(ctx context.Context) (*UserLocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLocation sets the old UserLocation of the mutation.
func withUserLocation(node *UserLocation) userlocationOption {
	return func(m *UserLocationMutation) {
		m.oldValue = func(context.Context) (*UserLocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserLocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserLocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserLocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArea sets the "area" field.
func (m *UserLocationMutation) SetArea(s string) {
	m.area = &s
}

// Area returns the value of the "area" field in the mutation.
func (m *UserLocationMutation) Area() (r string, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldArea returns the old "area" field's value of the UserLocation entity.
// If the UserLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLocationMutation) OldArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArea: %w", err)
	}
	return oldValue.Area, nil
}

// ResetArea resets all changes to the "area" field.
func (m *UserLocationMutation) ResetArea() {
	m.area = nil
}

// SetStreet sets the "street" field.
func (m *UserLocationMutation) SetStreet(s string) {
	m.street = &s
}

// Street returns the value of the "street" field in the mutation.
func (m *UserLocationMutation) Street() (r string, exists bool) {
	v := m.street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "street" field's value of the UserLocation entity.
// If the UserLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLocationMutation) OldStreet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ResetStreet resets all changes to the "street" field.
func (m *UserLocationMutation) ResetStreet() {
	m.street = nil
}

// SetHouse sets the "house" field.
func (m *UserLocationMutation) SetHouse(s string) {
	m.house = &s
}

// House returns the value of the "house" field in the mutation.
func (m *UserLocationMutation) House() (r string, exists bool) {
	v := m.house
	if v == nil {
		return
	}
	return *v, true
}

// OldHouse returns the old "house" field's value of the UserLocation entity.
// If the UserLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLocationMutation) OldHouse(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHouse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHouse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHouse: %w", err)
	}
	return oldValue.House, nil
}

// ResetHouse resets all changes to the "house" field.
func (m *UserLocationMutation) ResetHouse() {
	m.house = nil
}

// SetPostOffice sets the "post_office" field.
func (m *UserLocationMutation) SetPostOffice(s string) {
	m.post_office = &s
}

// PostOffice returns the value of the "post_office" field in the mutation.
func (m *UserLocationMutation) PostOffice() (r string, exists bool) {
	v := m.post_office
	if v == nil {
		return
	}
	return *v, true
}

// OldPostOffice returns the old "post_office" field's value of the UserLocation entity.
// If the UserLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLocationMutation) OldPostOffice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostOffice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostOffice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostOffice: %w", err)
	}
	return oldValue.PostOffice, nil
}

// ResetPostOffice resets all changes to the "post_office" field.
func (m *UserLocationMutation) ResetPostOffice() {
	m.post_office = nil
}

// SetPostCode sets the "post_code" field.
func (m *UserLocationMutation) SetPostCode(i int) {
	m.post_code = &i
	m.addpost_code = nil
}

// PostCode returns the value of the "post_code" field in the mutation.
func (m *UserLocationMutation) PostCode() (r int, exists bool) {
	v := m.post_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCode returns the old "post_code" field's value of the UserLocation entity.
// If the UserLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLocationMutation) OldPostCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCode: %w", err)
	}
	return oldValue.PostCode, nil
}

// AddPostCode adds i to the "post_code" field.
func (m *UserLocationMutation) AddPostCode(i int) {
	if m.addpost_code != nil {
		*m.addpost_code += i
	} else {
		m.addpost_code = &i
	}
}

// AddedPostCode returns the value that was added to the "post_code" field in this mutation.
func (m *UserLocationMutation) AddedPostCode() (r int, exists bool) {
	v := m.addpost_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostCode resets all changes to the "post_code" field.
func (m *UserLocationMutation) ResetPostCode() {
	m.post_code = nil
	m.addpost_code = nil
}

// SetPoliceStation sets the "police_station" field.
func (m *UserLocationMutation) SetPoliceStation(s string) {
	m.police_station = &s
}

// PoliceStation returns the value of the "police_station" field in the mutation.
func (m *UserLocationMutation) PoliceStation() (r string, exists bool) {
	v := m.police_station
	if v == nil {
		return
	}
	return *v, true
}

// OldPoliceStation returns the old "police_station" field's value of the UserLocation entity.
// If the UserLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLocationMutation) OldPoliceStation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoliceStation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoliceStation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoliceStation: %w", err)
	}
	return oldValue.PoliceStation, nil
}

// ResetPoliceStation resets all changes to the "police_station" field.
func (m *UserLocationMutation) ResetPoliceStation() {
	m.police_station = nil
}

// SetCity sets the "city" field.
func (m *UserLocationMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *UserLocationMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the UserLocation entity.
// If the UserLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLocationMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *UserLocationMutation) ResetCity() {
	m.city = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserLocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserLocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserLocation entity.
// If the UserLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserLocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserLocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserLocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserLocation entity.
// If the UserLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserLocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserLocationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserLocationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserLocation entity.
// If the UserLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLocationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserLocationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userlocation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserLocationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userlocation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserLocationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userlocation.FieldDeletedAt)
}

// SetGetUserID sets the "get_user" edge to the User entity by id.
func (m *UserLocationMutation) SetGetUserID(id int) {
	m.get_user = &id
}

// ClearGetUser clears the "get_user" edge to the User entity.
func (m *UserLocationMutation) ClearGetUser() {
	m.clearedget_user = true
}

// GetUserCleared reports if the "get_user" edge to the User entity was cleared.
func (m *UserLocationMutation) GetUserCleared() bool {
	return m.clearedget_user
}

// GetUserID returns the "get_user" edge ID in the mutation.
func (m *UserLocationMutation) GetUserID() (id int, exists bool) {
	if m.get_user != nil {
		return *m.get_user, true
	}
	return
}

// GetUserIDs returns the "get_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GetUserID instead. It exists only for internal usage by the builders.
func (m *UserLocationMutation) GetUserIDs() (ids []int) {
	if id := m.get_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGetUser resets all changes to the "get_user" edge.
func (m *UserLocationMutation) ResetGetUser() {
	m.get_user = nil
	m.clearedget_user = false
}

// AddUserLocationIDs adds the "user_locations" edge to the Checkout entity by ids.
func (m *UserLocationMutation) AddUserLocationIDs(ids ...int) {
	if m.user_locations == nil {
		m.user_locations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_locations[ids[i]] = struct{}{}
	}
}

// ClearUserLocations clears the "user_locations" edge to the Checkout entity.
func (m *UserLocationMutation) ClearUserLocations() {
	m.cleareduser_locations = true
}

// UserLocationsCleared reports if the "user_locations" edge to the Checkout entity was cleared.
func (m *UserLocationMutation) UserLocationsCleared() bool {
	return m.cleareduser_locations
}

// RemoveUserLocationIDs removes the "user_locations" edge to the Checkout entity by IDs.
func (m *UserLocationMutation) RemoveUserLocationIDs(ids ...int) {
	if m.removeduser_locations == nil {
		m.removeduser_locations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_locations, ids[i])
		m.removeduser_locations[ids[i]] = struct{}{}
	}
}

// RemovedUserLocations returns the removed IDs of the "user_locations" edge to the Checkout entity.
func (m *UserLocationMutation) RemovedUserLocationsIDs() (ids []int) {
	for id := range m.removeduser_locations {
		ids = append(ids, id)
	}
	return
}

// UserLocationsIDs returns the "user_locations" edge IDs in the mutation.
func (m *UserLocationMutation) UserLocationsIDs() (ids []int) {
	for id := range m.user_locations {
		ids = append(ids, id)
	}
	return
}

// ResetUserLocations resets all changes to the "user_locations" edge.
func (m *UserLocationMutation) ResetUserLocations() {
	m.user_locations = nil
	m.cleareduser_locations = false
	m.removeduser_locations = nil
}

// Where appends a list predicates to the UserLocationMutation builder.
func (m *UserLocationMutation) Where(ps ...predicate.UserLocation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserLocationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserLocation).
func (m *UserLocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLocationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.area != nil {
		fields = append(fields, userlocation.FieldArea)
	}
	if m.street != nil {
		fields = append(fields, userlocation.FieldStreet)
	}
	if m.house != nil {
		fields = append(fields, userlocation.FieldHouse)
	}
	if m.post_office != nil {
		fields = append(fields, userlocation.FieldPostOffice)
	}
	if m.post_code != nil {
		fields = append(fields, userlocation.FieldPostCode)
	}
	if m.police_station != nil {
		fields = append(fields, userlocation.FieldPoliceStation)
	}
	if m.city != nil {
		fields = append(fields, userlocation.FieldCity)
	}
	if m.created_at != nil {
		fields = append(fields, userlocation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userlocation.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userlocation.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userlocation.FieldArea:
		return m.Area()
	case userlocation.FieldStreet:
		return m.Street()
	case userlocation.FieldHouse:
		return m.House()
	case userlocation.FieldPostOffice:
		return m.PostOffice()
	case userlocation.FieldPostCode:
		return m.PostCode()
	case userlocation.FieldPoliceStation:
		return m.PoliceStation()
	case userlocation.FieldCity:
		return m.City()
	case userlocation.FieldCreatedAt:
		return m.CreatedAt()
	case userlocation.FieldUpdatedAt:
		return m.UpdatedAt()
	case userlocation.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userlocation.FieldArea:
		return m.OldArea(ctx)
	case userlocation.FieldStreet:
		return m.OldStreet(ctx)
	case userlocation.FieldHouse:
		return m.OldHouse(ctx)
	case userlocation.FieldPostOffice:
		return m.OldPostOffice(ctx)
	case userlocation.FieldPostCode:
		return m.OldPostCode(ctx)
	case userlocation.FieldPoliceStation:
		return m.OldPoliceStation(ctx)
	case userlocation.FieldCity:
		return m.OldCity(ctx)
	case userlocation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userlocation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userlocation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserLocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userlocation.FieldArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArea(v)
		return nil
	case userlocation.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case userlocation.FieldHouse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHouse(v)
		return nil
	case userlocation.FieldPostOffice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostOffice(v)
		return nil
	case userlocation.FieldPostCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCode(v)
		return nil
	case userlocation.FieldPoliceStation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoliceStation(v)
		return nil
	case userlocation.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case userlocation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userlocation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userlocation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserLocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLocationMutation) AddedFields() []string {
	var fields []string
	if m.addpost_code != nil {
		fields = append(fields, userlocation.FieldPostCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userlocation.FieldPostCode:
		return m.AddedPostCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userlocation.FieldPostCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostCode(v)
		return nil
	}
	return fmt.Errorf("unknown UserLocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userlocation.FieldDeletedAt) {
		fields = append(fields, userlocation.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLocationMutation) ClearField(name string) error {
	switch name {
	case userlocation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserLocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLocationMutation) ResetField(name string) error {
	switch name {
	case userlocation.FieldArea:
		m.ResetArea()
		return nil
	case userlocation.FieldStreet:
		m.ResetStreet()
		return nil
	case userlocation.FieldHouse:
		m.ResetHouse()
		return nil
	case userlocation.FieldPostOffice:
		m.ResetPostOffice()
		return nil
	case userlocation.FieldPostCode:
		m.ResetPostCode()
		return nil
	case userlocation.FieldPoliceStation:
		m.ResetPoliceStation()
		return nil
	case userlocation.FieldCity:
		m.ResetCity()
		return nil
	case userlocation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userlocation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userlocation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserLocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.get_user != nil {
		edges = append(edges, userlocation.EdgeGetUser)
	}
	if m.user_locations != nil {
		edges = append(edges, userlocation.EdgeUserLocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userlocation.EdgeGetUser:
		if id := m.get_user; id != nil {
			return []ent.Value{*id}
		}
	case userlocation.EdgeUserLocations:
		ids := make([]ent.Value, 0, len(m.user_locations))
		for id := range m.user_locations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_locations != nil {
		edges = append(edges, userlocation.EdgeUserLocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userlocation.EdgeUserLocations:
		ids := make([]ent.Value, 0, len(m.removeduser_locations))
		for id := range m.removeduser_locations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedget_user {
		edges = append(edges, userlocation.EdgeGetUser)
	}
	if m.cleareduser_locations {
		edges = append(edges, userlocation.EdgeUserLocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLocationMutation) EdgeCleared(name string) bool {
	switch name {
	case userlocation.EdgeGetUser:
		return m.clearedget_user
	case userlocation.EdgeUserLocations:
		return m.cleareduser_locations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLocationMutation) ClearEdge(name string) error {
	switch name {
	case userlocation.EdgeGetUser:
		m.ClearGetUser()
		return nil
	}
	return fmt.Errorf("unknown UserLocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLocationMutation) ResetEdge(name string) error {
	switch name {
	case userlocation.EdgeGetUser:
		m.ResetGetUser()
		return nil
	case userlocation.EdgeUserLocations:
		m.ResetUserLocations()
		return nil
	}
	return fmt.Errorf("unknown UserLocation edge %s", name)
}
